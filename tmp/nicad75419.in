<source file="systems/py/Django/trunk/django/db/models/sql/query.py.pyindent" startline="1" endline="1814">
from django.utils.copycompat import deepcopy
from django.utils.tree import Node
from django.utils.datastructures import SortedDict
from django.utils.encoding import force_unicode
from django.db import connections, DEFAULT_DB_ALIAS
from django.db.models import signals
from django.db.models.fields import FieldDoesNotExist
from django.db.models.query_utils import select_related_descend, InvalidQuery
from django.db.models.sql import aggregates as base_aggregates_module
from django.db.models.sql.constants import *
from django.db.models.sql.datastructures import EmptyResultSet, Empty, MultiJoin
from django.db.models.sql.expressions import SQLEvaluator
from django.db.models.sql.where import WhereNode, Constraint, EverythingNode, AND, OR
from django.core.exceptions import FieldError
__all__ = ['Query', 'RawQuery']
class RawQuery(object) :
INDENT
    def __init__(self, sql, using, params = None) :
    INDENT
        self.validate_sql(sql)
        self.params = params or ()
        self.sql = sql
        self.using = using
        self.cursor = None
    DEDENT
    def clone(self, using) :
    INDENT
        return RawQuery(self.sql, using, params = self.params)
    DEDENT
    def get_columns(self) :
    INDENT
        if self.cursor is None :
        INDENT
            self._execute_query()
        DEDENT
        converter = connections [self.using].introspection.table_name_converter
        return [converter(column_meta [0]) for column_meta in self.cursor.description]
    DEDENT
    def validate_sql(self, sql) :
    INDENT
        if not sql.lower().strip().startswith('select') :
        INDENT
            raise InvalidQuery('Raw queries are limited to SELECT queries. Use '
                'connection.cursor directly for other types of queries.')
        DEDENT
    DEDENT
    def __iter__(self) :
    INDENT
        self._execute_query()
        return iter(self.cursor)
    DEDENT
    def __repr__(self) :
    INDENT
        return "<RawQuery: %r>" % (self.sql % self.params)
    DEDENT
    def _execute_query(self) :
    INDENT
        self.cursor = connections [self.using].cursor()
        self.cursor.execute(self.sql, self.params)

    DEDENT
DEDENT
class Query(object) :
INDENT
    INNER = 'INNER JOIN'
    LOUTER = 'LEFT OUTER JOIN'
    alias_prefix = 'T'
    query_terms = QUERY_TERMS
    aggregates_module = base_aggregates_module
    compiler = 'SQLCompiler'
    def __init__(self, model, where = WhereNode) :
    INDENT
        self.model = model
        self.alias_refcount = {}
        self.alias_map = {}
        self.table_map = {}
        self.join_map = {}
        self.rev_join_map = {}
        self.quote_cache = {}
        self.default_cols = True
        self.default_ordering = True
        self.standard_ordering = True
        self.ordering_aliases = []
        self.select_fields = []
        self.related_select_fields = []
        self.dupe_avoidance = {}
        self.used_aliases = set()
        self.filter_is_sticky = False
        self.included_inherited_models = {}

        self.select = []
        self.tables = []
        self.where = where()
        self.where_class = where
        self.group_by = None
        self.having = where()
        self.order_by = []
        self.low_mark, self.high_mark = 0, None
        self.distinct = False
        self.select_related = False
        self.related_select_cols = []

        self.aggregates = SortedDict()
        self.aggregate_select_mask = None
        self._aggregate_select_cache = None

        self.max_depth = 5

        self.extra = SortedDict()
        self.extra_select_mask = None
        self._extra_select_cache = None
        self.extra_tables = ()
        self.extra_where = ()
        self.extra_params = ()
        self.extra_order_by = ()

        self.deferred_loading = (set(), True)
    DEDENT
    def __str__(self) :
    INDENT
        sql, params = self.get_compiler(DEFAULT_DB_ALIAS).as_sql()
        return sql % params
    DEDENT
    def __deepcopy__(self, memo) :
    INDENT
        result = self.clone()
        memo [id(self)] = result
        return result
    DEDENT
    def __getstate__(self) :
    INDENT
        obj_dict = self.__dict__.copy()
        obj_dict ['related_select_fields'] = []
        obj_dict ['related_select_cols'] = []

        obj_dict ['select_fields'] = [
            f is not None and f.name or None for f in obj_dict ['select_fields']
            ]
        return obj_dict
    DEDENT
    def __setstate__(self, obj_dict) :
    INDENT
        obj_dict ['select_fields'] = [
            name is not None and obj_dict ['model']._meta.get_field(name) or None for name in obj_dict ['select_fields']
            ]
        self.__dict__.update(obj_dict)
    DEDENT
    def prepare(self) :
    INDENT
        return self
    DEDENT
    def get_compiler(self, using = None, connection = None) :
    INDENT
        if using is None and connection is None :
        INDENT
            raise ValueError("Need either using or connection")
        DEDENT
        if using :
        INDENT
            connection = connections [using]
        DEDENT
        return connection.ops.compiler(self.compiler)(self, connection, using)
    DEDENT
    def get_meta(self) :
    INDENT
        return self.model._meta
    DEDENT
    def clone(self, klass = None, ** kwargs) :
    INDENT
        obj = Empty()
        obj.__class__ = klass or self.__class__
        obj.model = self.model
        obj.alias_refcount = self.alias_refcount.copy()
        obj.alias_map = self.alias_map.copy()
        obj.table_map = self.table_map.copy()
        obj.join_map = self.join_map.copy()
        obj.rev_join_map = self.rev_join_map.copy()
        obj.quote_cache = {}
        obj.default_cols = self.default_cols
        obj.default_ordering = self.default_ordering
        obj.standard_ordering = self.standard_ordering
        obj.included_inherited_models = self.included_inherited_models.copy()
        obj.ordering_aliases = []
        obj.select_fields = self.select_fields [:]
        obj.related_select_fields = self.related_select_fields [:]
        obj.dupe_avoidance = self.dupe_avoidance.copy()
        obj.select = self.select [:]
        obj.tables = self.tables [:]
        obj.where = deepcopy(self.where)
        obj.where_class = self.where_class
        if self.group_by is None :
        INDENT
            obj.group_by = None
        DEDENT
        else :
        INDENT
            obj.group_by = self.group_by [:]
        DEDENT
        obj.having = deepcopy(self.having)
        obj.order_by = self.order_by [:]
        obj.low_mark, obj.high_mark = self.low_mark, self.high_mark
        obj.distinct = self.distinct
        obj.select_related = self.select_related
        obj.related_select_cols = []
        obj.aggregates = deepcopy(self.aggregates)
        if self.aggregate_select_mask is None :
        INDENT
            obj.aggregate_select_mask = None
        DEDENT
        else :
        INDENT
            obj.aggregate_select_mask = self.aggregate_select_mask.copy()
        DEDENT
        if self._aggregate_select_cache is None :
        INDENT
            obj._aggregate_select_cache = None
        DEDENT
        else :
        INDENT
            obj._aggregate_select_cache = self._aggregate_select_cache.copy()
        DEDENT
        obj.max_depth = self.max_depth
        obj.extra = self.extra.copy()
        if self.extra_select_mask is None :
        INDENT
            obj.extra_select_mask = None
        DEDENT
        else :
        INDENT
            obj.extra_select_mask = self.extra_select_mask.copy()
        DEDENT
        if self._extra_select_cache is None :
        INDENT
            obj._extra_select_cache = None
        DEDENT
        else :
        INDENT
            obj._extra_select_cache = self._extra_select_cache.copy()
        DEDENT
        obj.extra_tables = self.extra_tables
        obj.extra_where = self.extra_where
        obj.extra_params = self.extra_params
        obj.extra_order_by = self.extra_order_by
        obj.deferred_loading = deepcopy(self.deferred_loading)
        if self.filter_is_sticky and self.used_aliases :
        INDENT
            obj.used_aliases = self.used_aliases.copy()
        DEDENT
        else :
        INDENT
            obj.used_aliases = set()
        DEDENT
        obj.filter_is_sticky = False
        obj.__dict__.update(kwargs)
        if hasattr(obj, '_setup_query') :
        INDENT
            obj._setup_query()
        DEDENT
        return obj
    DEDENT
    def convert_values(self, value, field, connection) :
    INDENT
        return connection.ops.convert_values(value, field)
    DEDENT
    def resolve_aggregate(self, value, aggregate, connection) :
    INDENT
        if value is None :
        INDENT
            if aggregate.is_ordinal :
            INDENT
                return 0
            DEDENT
            return value
        DEDENT
        elif aggregate.is_ordinal :
        INDENT
            return int(value)
        DEDENT
        elif aggregate.is_computed :
        INDENT
            return float(value)
        DEDENT
        else :
        INDENT
            return self.convert_values(value, aggregate.field, connection)
        DEDENT
    DEDENT
    def get_aggregation(self, using) :
    INDENT
        if not self.aggregate_select :
        INDENT
            return {}

        DEDENT
        if self.group_by is not None :
        INDENT
            from subqueries import AggregateQuery
            query = AggregateQuery(self.model)
            obj = self.clone()

            for alias, aggregate in self.aggregate_select.items() :
            INDENT
                if aggregate.is_summary :
                INDENT
                    query.aggregate_select [alias] = aggregate
                    del obj.aggregate_select [alias]

                DEDENT
            DEDENT
            query.add_subquery(obj, using)
        DEDENT
        else :
        INDENT
            query = self
            self.select = []
            self.default_cols = False
            self.extra = {}
            self.remove_inherited_models()
        DEDENT
        query.clear_ordering(True)
        query.clear_limits()
        query.select_related = False
        query.related_select_cols = []
        query.related_select_fields = []
        result = query.get_compiler(using).execute_sql(SINGLE)
        if result is None :
        INDENT
            result = [None for q in query.aggregate_select.items()]
        DEDENT
        return dict([
                (alias, self.resolve_aggregate(val, aggregate, connection = connections [using])) for (alias, aggregate), val
                in zip(query.aggregate_select.items(), result)
                ])
    DEDENT
    def get_count(self, using) :
    INDENT
        obj = self.clone()
        if len(self.select) > 1 or self.aggregate_select :
        INDENT
            from subqueries import AggregateQuery
            subquery = obj
            subquery.clear_ordering(True)
            subquery.clear_limits()
            obj = AggregateQuery(obj.model)
            obj.add_subquery(subquery, using = using)
        DEDENT
        obj.add_count_column()
        number = obj.get_aggregation(using = using) [None]

        number = max(0, number - self.low_mark)
        if self.high_mark is not None :
        INDENT
            number = min(number, self.high_mark - self.low_mark)
        DEDENT
        return number
    DEDENT
    def has_results(self, using) :
    INDENT
        q = self.clone()
        q.add_extra({'a' : 1}, None, None, None, None, None)
        q.add_fields(())
        q.set_extra_mask(('a',))
        q.set_aggregate_mask(())
        q.clear_ordering()
        q.set_limits(high = 1)
        compiler = q.get_compiler(using = using)
        return bool(compiler.execute_sql(SINGLE))
    DEDENT
    def combine(self, rhs, connector) :
    INDENT
        assert self.model == rhs.model, "Cannot combine queries on two different base models."
        assert self.can_filter(), "Cannot combine queries once a slice has been taken."
        assert self.distinct == rhs.distinct, "Cannot combine a unique query with a non-unique query."
        self.remove_inherited_models()
        change_map = {}
        used = set()
        conjunction = (connector == AND)
        first = True
        for alias in rhs.tables :
        INDENT
            if not rhs.alias_refcount [alias] :
            INDENT
                continue
            DEDENT
            promote = (rhs.alias_map [alias] [JOIN_TYPE] == self.LOUTER)
            new_alias = self.join(rhs.rev_join_map [alias],
                (conjunction and not first), used, promote, not conjunction)
            used.add(new_alias)
            change_map [alias] = new_alias
            first = False

        DEDENT
        if not conjunction :
        INDENT
            for alias in self.tables [1 :] :
            INDENT
                if self.alias_refcount [alias] == 1 :
                INDENT
                    self.promote_alias(alias, True)
                    break
                DEDENT
            DEDENT
        DEDENT
        if rhs.where :
        INDENT
            w = deepcopy(rhs.where)
            w.relabel_aliases(change_map)
            if not self.where :
            INDENT
                self.where.add(EverythingNode(), AND)
            DEDENT
        DEDENT
        elif self.where :
        INDENT
            w = self.where_class()
            w.add(EverythingNode(), AND)
        DEDENT
        else :
        INDENT
            w = self.where_class()
        DEDENT
        self.where.add(w, connector)

        self.select = []
        for col in rhs.select :
        INDENT
            if isinstance(col, (list, tuple)) :
            INDENT
                self.select.append((change_map.get(col [0], col [0]), col [1]))
            DEDENT
            else :
            INDENT
                item = deepcopy(col)
                item.relabel_aliases(change_map)
                self.select.append(item)
            DEDENT
        DEDENT
        self.select_fields = rhs.select_fields [:]
        if connector == OR :
        INDENT
            if self.extra and rhs.extra :
            INDENT
                raise ValueError("When merging querysets using 'or', you "
                    "cannot have extra(select=...) on both sides.")
            DEDENT
            if self.extra_where and rhs.extra_where :
            INDENT
                raise ValueError("When merging querysets using 'or', you "
                    "cannot have extra(where=...) on both sides.")
            DEDENT
        DEDENT
        self.extra.update(rhs.extra)
        extra_select_mask = set()
        if self.extra_select_mask is not None :
        INDENT
            extra_select_mask.update(self.extra_select_mask)
        DEDENT
        if rhs.extra_select_mask is not None :
        INDENT
            extra_select_mask.update(rhs.extra_select_mask)
        DEDENT
        if extra_select_mask :
        INDENT
            self.set_extra_mask(extra_select_mask)
        DEDENT
        self.extra_tables += rhs.extra_tables
        self.extra_where += rhs.extra_where
        self.extra_params += rhs.extra_params

        self.order_by = rhs.order_by and rhs.order_by [:] or self.order_by
        self.extra_order_by = rhs.extra_order_by or self.extra_order_by
    DEDENT
    def deferred_to_data(self, target, callback) :
    INDENT
        field_names, defer = self.deferred_loading
        if not field_names :
        INDENT
            return
        DEDENT
        columns = set()
        orig_opts = self.model._meta
        seen = {}
        must_include = {self.model : set([orig_opts.pk])}
        for field_name in field_names :
        INDENT
            parts = field_name.split(LOOKUP_SEP)
            cur_model = self.model
            opts = orig_opts
            for name in parts [: - 1] :
            INDENT
                old_model = cur_model
                source = opts.get_field_by_name(name) [0]
                cur_model = opts.get_field_by_name(name) [0].rel.to
                opts = cur_model._meta

                must_include [old_model].add(source)
                add_to_dict(must_include, cur_model, opts.pk)
            DEDENT
            field, model, _, _ = opts.get_field_by_name(parts [- 1])
            if model is None :
            INDENT
                model = cur_model
            DEDENT
            add_to_dict(seen, model, field)
        DEDENT
        if defer :
        INDENT
            workset = {}
            for model, values in seen.iteritems() :
            INDENT
                for field in model._meta.local_fields :
                INDENT
                    if field in values :
                    INDENT
                        continue
                    DEDENT
                    add_to_dict(workset, model, field)
                DEDENT
            DEDENT
            for model, values in must_include.iteritems() :
            INDENT
                if model in workset :
                INDENT
                    workset [model].update(values)
                DEDENT
            DEDENT
            for model, values in workset.iteritems() :
            INDENT
                callback(target, model, values)
            DEDENT
        DEDENT
        else :
        INDENT
            for model, values in must_include.iteritems() :
            INDENT
                if model in seen :
                INDENT
                    seen [model].update(values)
                DEDENT
                else :
                INDENT
                    seen [model] = values

                DEDENT
            DEDENT
            for model in orig_opts.get_parent_list() :
            INDENT
                if model not in seen :
                INDENT
                    seen [model] = set()
                DEDENT
            DEDENT
            for model, values in seen.iteritems() :
            INDENT
                callback(target, model, values)

            DEDENT
        DEDENT
    DEDENT
    def deferred_to_columns_cb(self, target, model, fields) :
    INDENT
        table = model._meta.db_table
        if table not in target :
        INDENT
            target [table] = set()
        DEDENT
        for field in fields :
        INDENT
            target [table].add(field.column)

        DEDENT
    DEDENT
    def table_alias(self, table_name, create = False) :
    INDENT
        current = self.table_map.get(table_name)
        if not create and current :
        INDENT
            alias = current [0]
            self.alias_refcount [alias] += 1
            return alias, False

        DEDENT
        if current :
        INDENT
            alias = '%s%d' % (self.alias_prefix, len(self.alias_map) + 1)
            current.append(alias)
        DEDENT
        else :
        INDENT
            alias = table_name
            self.table_map [alias] = [alias]
        DEDENT
        self.alias_refcount [alias] = 1
        self.tables.append(alias)
        return alias, True
    DEDENT
    def ref_alias(self, alias) :
    INDENT
        self.alias_refcount [alias] += 1
    DEDENT
    def unref_alias(self, alias) :
    INDENT
        self.alias_refcount [alias] -= 1
    DEDENT
    def promote_alias(self, alias, unconditional = False) :
    INDENT
        if ((unconditional or self.alias_map [alias] [NULLABLE]) and
            self.alias_map [alias] [JOIN_TYPE] ! = self.LOUTER) :
        INDENT
            data = list(self.alias_map [alias])
            data [JOIN_TYPE] = self.LOUTER
            self.alias_map [alias] = tuple(data)
            return True
        DEDENT
        return False
    DEDENT
    def promote_alias_chain(self, chain, must_promote = False) :
    INDENT
        for alias in chain :
        INDENT
            if self.promote_alias(alias, must_promote) :
            INDENT
                must_promote = True
            DEDENT
        DEDENT
    DEDENT
    def promote_unused_aliases(self, initial_refcounts, used_aliases) :
    INDENT
        considered = {}
        for alias in self.tables :
        INDENT
            if alias not in used_aliases :
            INDENT
                continue
            DEDENT
            if (alias not in initial_refcounts or
                self.alias_refcount [alias] == initial_refcounts [alias]) :
            INDENT
                parent = self.alias_map [alias] [LHS_ALIAS]
                must_promote = considered.get(parent, False)
                promoted = self.promote_alias(alias, must_promote)
                considered [alias] = must_promote or promoted
            DEDENT
        DEDENT
    DEDENT
    def change_aliases(self, change_map) :
    INDENT
        assert set(change_map.keys()).intersection(set(change_map.values())) == set()
        self.where.relabel_aliases(change_map)
        self.having.relabel_aliases(change_map)
        for columns in (self.select, self.aggregates.values(), self.group_by or []) :
        INDENT
            for pos, col in enumerate(columns) :
            INDENT
                if isinstance(col, (list, tuple)) :
                INDENT
                    old_alias = col [0]
                    columns [pos] = (change_map.get(old_alias, old_alias), col [1])
                DEDENT
                else :
                INDENT
                    col.relabel_aliases(change_map)

                DEDENT
            DEDENT
        DEDENT
        for old_alias, new_alias in change_map.iteritems() :
        INDENT
            alias_data = list(self.alias_map [old_alias])
            alias_data [RHS_ALIAS] = new_alias
            t = self.rev_join_map [old_alias]
            data = list(self.join_map [t])
            data [data.index(old_alias)] = new_alias
            self.join_map [t] = tuple(data)
            self.rev_join_map [new_alias] = t
            del self.rev_join_map [old_alias]
            self.alias_refcount [new_alias] = self.alias_refcount [old_alias]
            del self.alias_refcount [old_alias]
            self.alias_map [new_alias] = tuple(alias_data)
            del self.alias_map [old_alias]

            table_aliases = self.table_map [alias_data [TABLE_NAME]]
            for pos, alias in enumerate(table_aliases) :
            INDENT
                if alias == old_alias :
                INDENT
                    table_aliases [pos] = new_alias
                    break
                DEDENT
            DEDENT
            for pos, alias in enumerate(self.tables) :
            INDENT
                if alias == old_alias :
                INDENT
                    self.tables [pos] = new_alias
                    break
                DEDENT
            DEDENT
        DEDENT
        for key, alias in self.included_inherited_models.items() :
        INDENT
            if alias in change_map :
            INDENT
                self.included_inherited_models [key] = change_map [alias]

            DEDENT
        DEDENT
        for alias, data in self.alias_map.iteritems() :
        INDENT
            lhs = data [LHS_ALIAS]
            if lhs in change_map :
            INDENT
                data = list(data)
                data [LHS_ALIAS] = change_map [lhs]
                self.alias_map [alias] = tuple(data)
            DEDENT
        DEDENT
    DEDENT
    def bump_prefix(self, exceptions = ()) :
    INDENT
        current = ord(self.alias_prefix)
        assert current < ord('Z')
        prefix = chr(current + 1)
        self.alias_prefix = prefix
        change_map = {}
        for pos, alias in enumerate(self.tables) :
        INDENT
            if alias in exceptions :
            INDENT
                continue
            DEDENT
            new_alias = '%s%d' % (prefix, pos)
            change_map [alias] = new_alias
            self.tables [pos] = new_alias
        DEDENT
        self.change_aliases(change_map)
    DEDENT
    def get_initial_alias(self) :
    INDENT
        if self.tables :
        INDENT
            alias = self.tables [0]
            self.ref_alias(alias)
        DEDENT
        else :
        INDENT
            alias = self.join((None, self.model._meta.db_table, None, None))
        DEDENT
        return alias
    DEDENT
    def count_active_tables(self) :
    INDENT
        return len([1 for count in self.alias_refcount.itervalues() if count])
    DEDENT
    def join(self, connection, always_create = False, exclusions = (),
    promote = False, outer_if_first = False, nullable = False, reuse = None) :
    INDENT
        lhs, table, lhs_col, col = connection
        if lhs in self.alias_map :
        INDENT
            lhs_table = self.alias_map [lhs] [TABLE_NAME]
        DEDENT
        else :
        INDENT
            lhs_table = lhs
        DEDENT
        if reuse and always_create and table in self.table_map :
        INDENT
            exclusions = set(self.table_map [table]).difference(reuse).union(set(exclusions))
            always_create = False
        DEDENT
        t_ident = (lhs_table, table, lhs_col, col)
        if not always_create :
        INDENT
            for alias in self.join_map.get(t_ident, ()) :
            INDENT
                if alias not in exclusions :
                INDENT
                    if lhs_table and not self.alias_refcount [self.alias_map [alias] [LHS_ALIAS]] :
                    INDENT
                        continue
                    DEDENT
                    if self.alias_map [alias] [LHS_ALIAS] ! = lhs :
                    INDENT
                        continue
                    DEDENT
                    self.ref_alias(alias)
                    if promote :
                    INDENT
                        self.promote_alias(alias)
                    DEDENT
                    return alias

                DEDENT
            DEDENT
        DEDENT
        alias, _ = self.table_alias(table, True)
        if not lhs :
        INDENT
            join_type = None
        DEDENT
        elif promote or outer_if_first :
        INDENT
            join_type = self.LOUTER
        DEDENT
        else :
        INDENT
            join_type = self.INNER
        DEDENT
        join = (table, alias, join_type, lhs, lhs_col, col, nullable)
        self.alias_map [alias] = join
        if t_ident in self.join_map :
        INDENT
            self.join_map [t_ident] += (alias,)
        DEDENT
        else :
        INDENT
            self.join_map [t_ident] = (alias,)
        DEDENT
        self.rev_join_map [alias] = t_ident
        return alias
    DEDENT
    def setup_inherited_models(self) :
    INDENT
        opts = self.model._meta
        root_alias = self.tables [0]
        seen = {None : root_alias}

        proxied_model = get_proxied_model(opts)
        for field, model in opts.get_fields_with_model() :
        INDENT
            if model not in seen :
            INDENT
                if model is proxied_model :
                INDENT
                    seen [model] = root_alias
                DEDENT
                else :
                INDENT
                    link_field = opts.get_ancestor_link(model)
                    seen [model] = self.join((root_alias, model._meta.db_table,
                            link_field.column, model._meta.pk.column))
                DEDENT
            DEDENT
        DEDENT
        self.included_inherited_models = seen
    DEDENT
    def remove_inherited_models(self) :
    INDENT
        for key, alias in self.included_inherited_models.items() :
        INDENT
            if key :
            INDENT
                self.unref_alias(alias)
            DEDENT
        DEDENT
        self.included_inherited_models = {}

    DEDENT
    def add_aggregate(self, aggregate, model, alias, is_summary) :
    INDENT
        opts = model._meta
        field_list = aggregate.lookup.split(LOOKUP_SEP)
        if (len(field_list) == 1 and
            aggregate.lookup in self.aggregates.keys()) :
        INDENT
            field_name = field_list [0]
            col = field_name
            source = self.aggregates [field_name]
            if not is_summary :
            INDENT
                raise FieldError("Cannot compute %s('%s'): '%s' is an aggregate" % (
                        aggregate.name, field_name, field_name))
            DEDENT
        DEDENT
        elif ((len(field_list) > 1) or
            (field_list [0] not in [i.name for i in opts.fields]) or
            self.group_by is None or
            not is_summary) :
        INDENT
            field, source, opts, join_list, last, _ = self.setup_joins(
                field_list, opts, self.get_initial_alias(), False)

            col, _, join_list = self.trim_joins(source, join_list, last, False)

            for column_alias in join_list :
            INDENT
                self.promote_alias(column_alias, unconditional = True)
            DEDENT
            col = (join_list [- 1], col)
        DEDENT
        else :
        INDENT
            field_name = field_list [0]
            source = opts.get_field(field_name)
            col = field_name

        DEDENT
        aggregate.add_to_query(self, alias, col = col, source = source, is_summary = is_summary)
    DEDENT
    def add_filter(self, filter_expr, connector = AND, negate = False, trim = False,
    can_reuse = None, process_extras = True) :
    INDENT
        arg, value = filter_expr
        parts = arg.split(LOOKUP_SEP)
        if not parts :
        INDENT
            raise FieldError("Cannot parse keyword query %r" % arg)
        DEDENT
        if len(parts) == 1 or parts [- 1] not in self.query_terms :
        INDENT
            lookup_type = 'exact'
        DEDENT
        else :
        INDENT
            lookup_type = parts.pop()

        DEDENT
        having_clause = False

        if value is None :
        INDENT
            if lookup_type ! = 'exact' :
            INDENT
                raise ValueError("Cannot use None as a query value")
            DEDENT
            lookup_type = 'isnull'
            value = True
        DEDENT
        elif callable(value) :
        INDENT
            value = value()
        DEDENT
        elif hasattr(value, 'evaluate') :
        INDENT
            value = SQLEvaluator(value, self)
            having_clause = value.contains_aggregate
        DEDENT
        for alias, aggregate in self.aggregates.items() :
        INDENT
            if alias == parts [0] :
            INDENT
                entry = self.where_class()
                entry.add((aggregate, lookup_type, value), AND)
                if negate :
                INDENT
                    entry.negate()
                DEDENT
                self.having.add(entry, AND)
                return
            DEDENT
        DEDENT
        opts = self.get_meta()
        alias = self.get_initial_alias()
        allow_many = trim or not negate
        try :
        INDENT
            field, target, opts, join_list, last, extra_filters = self.setup_joins(
                parts, opts, alias, True, allow_many, can_reuse = can_reuse,
                negate = negate, process_extras = process_extras)
        DEDENT
        except MultiJoin, e :
        INDENT
            self.split_exclude(filter_expr, LOOKUP_SEP.join(parts [: e.level]),
                can_reuse)
            return
        DEDENT
        if (lookup_type == 'isnull' and value is True and not negate and
            len(join_list) > 1) :
        INDENT
            self.promote_alias_chain(join_list)

        DEDENT
        col, alias, join_list = self.trim_joins(target, join_list, last, trim)
        if connector == OR :
        INDENT
            join_it = iter(join_list)
            table_it = iter(self.tables)
            join_it.next(), table_it.next()
            table_promote = False
            join_promote = False
            for join in join_it :
            INDENT
                table = table_it.next()
                if join == table and self.alias_refcount [join] > 1 :
                INDENT
                    continue
                DEDENT
                join_promote = self.promote_alias(join)
                if table ! = join :
                INDENT
                    table_promote = self.promote_alias(table)
                DEDENT
                break
            DEDENT
            self.promote_alias_chain(join_it, join_promote)
            self.promote_alias_chain(table_it, table_promote)

        DEDENT
        if having_clause :
        INDENT
            self.having.add((Constraint(alias, col, field), lookup_type, value),
                connector)
        DEDENT
        else :
        INDENT
            self.where.add((Constraint(alias, col, field), lookup_type, value),
                connector)
        DEDENT
        if negate :
        INDENT
            self.promote_alias_chain(join_list)
            if lookup_type ! = 'isnull' :
            INDENT
                if len(join_list) > 1 :
                INDENT
                    for alias in join_list :
                    INDENT
                        if self.alias_map [alias] [JOIN_TYPE] == self.LOUTER :
                        INDENT
                            j_col = self.alias_map [alias] [RHS_JOIN_COL]
                            entry = self.where_class()
                            entry.add((Constraint(alias, j_col, None), 'isnull', True), AND)
                            entry.negate()
                            self.where.add(entry, AND)
                            break
                        DEDENT
                    DEDENT
                DEDENT
                elif not (lookup_type == 'in'
                    and not hasattr(value, 'as_sql')
                    and not hasattr(value, '_as_sql')
                    and not value) and field.null :
                INDENT
                    entry = self.where_class()
                    entry.add((Constraint(alias, col, None), 'isnull', True), AND)
                    entry.negate()
                    self.where.add(entry, AND)
                DEDENT
            DEDENT
        DEDENT
        if can_reuse is not None :
        INDENT
            can_reuse.update(join_list)
        DEDENT
        if process_extras :
        INDENT
            for filter in extra_filters :
            INDENT
                self.add_filter(filter, negate = negate, can_reuse = can_reuse,
                    process_extras = False)
            DEDENT
        DEDENT
    DEDENT
    def add_q(self, q_object, used_aliases = None) :
    INDENT
        if used_aliases is None :
        INDENT
            used_aliases = self.used_aliases
        DEDENT
        if hasattr(q_object, 'add_to_query') :
        INDENT
            q_object.add_to_query(self, used_aliases)
        DEDENT
        else :
        INDENT
            if self.where and q_object.connector ! = AND and len(q_object) > 1 :
            INDENT
                self.where.start_subtree(AND)
                subtree = True
            DEDENT
            else :
            INDENT
                subtree = False
            DEDENT
            connector = AND
            for child in q_object.children :
            INDENT
                if connector == OR :
                INDENT
                    refcounts_before = self.alias_refcount.copy()
                DEDENT
                if isinstance(child, Node) :
                INDENT
                    self.where.start_subtree(connector)
                    self.add_q(child, used_aliases)
                    self.where.end_subtree()
                DEDENT
                else :
                INDENT
                    self.add_filter(child, connector, q_object.negated,
                        can_reuse = used_aliases)
                DEDENT
                if connector == OR :
                INDENT
                    self.promote_unused_aliases(refcounts_before, used_aliases)
                DEDENT
                connector = q_object.connector
            DEDENT
            if q_object.negated :
            INDENT
                self.where.negate()
            DEDENT
            if subtree :
            INDENT
                self.where.end_subtree()
            DEDENT
        DEDENT
        if self.filter_is_sticky :
        INDENT
            self.used_aliases = used_aliases
        DEDENT
    DEDENT
    def setup_joins(self, names, opts, alias, dupe_multis, allow_many = True,
    allow_explicit_fk = False, can_reuse = None, negate = False,
    process_extras = True) :
    INDENT
        joins = [alias]
        last = [0]
        dupe_set = set()
        exclusions = set()
        extra_filters = []
        for pos, name in enumerate(names) :
        INDENT
            try :
            INDENT
                exclusions.add(int_alias)
            DEDENT
            except NameError :
            INDENT
                pass
            DEDENT
            exclusions.add(alias)
            last.append(len(joins))
            if name == 'pk' :
            INDENT
                name = opts.pk.name
            DEDENT
            try :
            INDENT
                field, model, direct, m2m = opts.get_field_by_name(name)
            DEDENT
            except FieldDoesNotExist :
            INDENT
                for f in opts.fields :
                INDENT
                    if allow_explicit_fk and name == f.attname :
                    INDENT
                        field, model, direct, m2m = opts.get_field_by_name(f.name)
                        break
                    DEDENT
                DEDENT
                else :
                INDENT
                    names = opts.get_all_field_names() + self.aggregate_select.keys()
                    raise FieldError("Cannot resolve keyword %r into field. "
                        "Choices are: %s" % (name, ", ".join(names)))
                DEDENT
            DEDENT
            if not allow_many and (m2m or not direct) :
            INDENT
                for alias in joins :
                INDENT
                    self.unref_alias(alias)
                DEDENT
                raise MultiJoin(pos + 1)
            DEDENT
            if model :
            INDENT
                proxied_model = get_proxied_model(opts)
                for int_model in opts.get_base_chain(model) :
                INDENT
                    if int_model is proxied_model :
                    INDENT
                        opts = int_model._meta
                    DEDENT
                    else :
                    INDENT
                        lhs_col = opts.parents [int_model].column
                        dedupe = lhs_col in opts.duplicate_targets
                        if dedupe :
                        INDENT
                            exclusions.update(self.dupe_avoidance.get(
                                    (id(opts), lhs_col), ()))
                            dupe_set.add((opts, lhs_col))
                        DEDENT
                        opts = int_model._meta
                        alias = self.join((alias, opts.db_table, lhs_col,
                                opts.pk.column), exclusions = exclusions)
                        joins.append(alias)
                        exclusions.add(alias)
                        for (dupe_opts, dupe_col) in dupe_set :
                        INDENT
                            self.update_dupe_avoidance(dupe_opts, dupe_col,
                                alias)
                        DEDENT
                    DEDENT
                DEDENT
            DEDENT
            cached_data = opts._join_cache.get(name)
            orig_opts = opts
            dupe_col = direct and field.column or field.field.column
            dedupe = dupe_col in opts.duplicate_targets
            if dupe_set or dedupe :
            INDENT
                if dedupe :
                INDENT
                    dupe_set.add((opts, dupe_col))
                DEDENT
                exclusions.update(self.dupe_avoidance.get((id(opts), dupe_col),
                        ()))
            DEDENT
            if process_extras and hasattr(field, 'extra_filters') :
            INDENT
                extra_filters.extend(field.extra_filters(names, pos, negate))
            DEDENT
            if direct :
            INDENT
                if m2m :
                INDENT
                    if cached_data :
                    INDENT
                        (table1, from_col1, to_col1, table2, from_col2,
                            to_col2, opts, target) = cached_data
                    DEDENT
                    else :
                    INDENT
                        table1 = field.m2m_db_table()
                        from_col1 = opts.pk.column
                        to_col1 = field.m2m_column_name()
                        opts = field.rel.to._meta
                        table2 = opts.db_table
                        from_col2 = field.m2m_reverse_name()
                        to_col2 = opts.pk.column
                        target = opts.pk
                        orig_opts._join_cache [name] = (table1, from_col1,
                            to_col1, table2, from_col2, to_col2, opts,
                            target)
                    DEDENT
                    int_alias = self.join((alias, table1, from_col1, to_col1),
                        dupe_multis, exclusions, nullable = True,
                        reuse = can_reuse)
                    if int_alias == table2 and from_col2 == to_col2 :
                    INDENT
                        joins.append(int_alias)
                        alias = int_alias
                    DEDENT
                    else :
                    INDENT
                        alias = self.join(
                            (int_alias, table2, from_col2, to_col2),
                            dupe_multis, exclusions, nullable = True,
                            reuse = can_reuse)
                        joins.extend([int_alias, alias])
                    DEDENT
                DEDENT
                elif field.rel :
                INDENT
                    if cached_data :
                    INDENT
                        (table, from_col, to_col, opts, target) = cached_data
                    DEDENT
                    else :
                    INDENT
                        opts = field.rel.to._meta
                        target = field.rel.get_related_field()
                        table = opts.db_table
                        from_col = field.column
                        to_col = target.column
                        orig_opts._join_cache [name] = (table, from_col, to_col,
                            opts, target)
                    DEDENT
                    alias = self.join((alias, table, from_col, to_col),
                        exclusions = exclusions, nullable = field.null)
                    joins.append(alias)
                DEDENT
                else :
                INDENT
                    target = field
                    break
                DEDENT
            DEDENT
            else :
            INDENT
                orig_field = field
                field = field.field
                if m2m :
                INDENT
                    if cached_data :
                    INDENT
                        (table1, from_col1, to_col1, table2, from_col2,
                            to_col2, opts, target) = cached_data
                    DEDENT
                    else :
                    INDENT
                        table1 = field.m2m_db_table()
                        from_col1 = opts.pk.column
                        to_col1 = field.m2m_reverse_name()
                        opts = orig_field.opts
                        table2 = opts.db_table
                        from_col2 = field.m2m_column_name()
                        to_col2 = opts.pk.column
                        target = opts.pk
                        orig_opts._join_cache [name] = (table1, from_col1,
                            to_col1, table2, from_col2, to_col2, opts,
                            target)
                    DEDENT
                    int_alias = self.join((alias, table1, from_col1, to_col1),
                        dupe_multis, exclusions, nullable = True,
                        reuse = can_reuse)
                    alias = self.join((int_alias, table2, from_col2, to_col2),
                        dupe_multis, exclusions, nullable = True,
                        reuse = can_reuse)
                    joins.extend([int_alias, alias])
                DEDENT
                else :
                INDENT
                    if cached_data :
                    INDENT
                        (table, from_col, to_col, opts, target) = cached_data
                    DEDENT
                    else :
                    INDENT
                        local_field = opts.get_field_by_name(
                            field.rel.field_name) [0]
                        opts = orig_field.opts
                        table = opts.db_table
                        from_col = local_field.column
                        to_col = field.column
                        target = opts.pk
                        orig_opts._join_cache [name] = (table, from_col, to_col,
                            opts, target)
                    DEDENT
                    alias = self.join((alias, table, from_col, to_col),
                        dupe_multis, exclusions, nullable = True,
                        reuse = can_reuse)
                    joins.append(alias)
                DEDENT
            DEDENT
            for (dupe_opts, dupe_col) in dupe_set :
            INDENT
                try :
                INDENT
                    self.update_dupe_avoidance(dupe_opts, dupe_col, int_alias)
                DEDENT
                except NameError :
                INDENT
                    self.update_dupe_avoidance(dupe_opts, dupe_col, alias)
                DEDENT
            DEDENT
        DEDENT
        if pos ! = len(names) - 1 :
        INDENT
            if pos == len(names) - 2 :
            INDENT
                raise FieldError("Join on field %r not permitted. Did you misspell %r for the lookup type?" % (name, names [pos + 1]))
            DEDENT
            else :
            INDENT
                raise FieldError("Join on field %r not permitted." % name)
            DEDENT
        DEDENT
        return field, target, opts, joins, last, extra_filters
    DEDENT
    def trim_joins(self, target, join_list, last, trim) :
    INDENT
        final = len(join_list)
        penultimate = last.pop()
        if penultimate == final :
        INDENT
            penultimate = last.pop()
        DEDENT
        if trim and len(join_list) > 1 :
        INDENT
            extra = join_list [penultimate :]
            join_list = join_list [: penultimate]
            final = penultimate
            penultimate = last.pop()
            col = self.alias_map [extra [0]] [LHS_JOIN_COL]
            for alias in extra :
            INDENT
                self.unref_alias(alias)
            DEDENT
        DEDENT
        else :
        INDENT
            col = target.column
        DEDENT
        alias = join_list [- 1]
        while final > 1 :
        INDENT
            join = self.alias_map [alias]
            if col ! = join [RHS_JOIN_COL] or join [JOIN_TYPE] ! = self.INNER :
            INDENT
                break
            DEDENT
            self.unref_alias(alias)
            alias = join [LHS_ALIAS]
            col = join [LHS_JOIN_COL]
            join_list = join_list [: - 1]
            final -= 1
            if final == penultimate :
            INDENT
                penultimate = last.pop()
            DEDENT
        DEDENT
        return col, alias, join_list
    DEDENT
    def update_dupe_avoidance(self, opts, col, alias) :
    INDENT
        ident = id(opts)
        for name in opts.duplicate_targets [col] :
        INDENT
            try :
            INDENT
                self.dupe_avoidance [ident, name].add(alias)
            DEDENT
            except KeyError :
            INDENT
                self.dupe_avoidance [ident, name] = set([alias])
            DEDENT
        DEDENT
    DEDENT
    def split_exclude(self, filter_expr, prefix, can_reuse) :
    INDENT
        query = Query(self.model)
        query.add_filter(filter_expr, can_reuse = can_reuse)
        query.bump_prefix()
        query.clear_ordering(True)
        query.set_start(prefix)
        self.add_filter(('%s__in' % prefix, query), negate = True, trim = True,
            can_reuse = can_reuse)

        active_positions = [pos for (pos, count) in
            enumerate(query.alias_refcount.itervalues()) if count]
        if active_positions [- 1] > 1 :
        INDENT
            self.add_filter(('%s__isnull' % prefix, False), negate = True,
                trim = True, can_reuse = can_reuse)
        DEDENT
    DEDENT
    def set_limits(self, low = None, high = None) :
    INDENT
        if high is not None :
        INDENT
            if self.high_mark is not None :
            INDENT
                self.high_mark = min(self.high_mark, self.low_mark + high)
            DEDENT
            else :
            INDENT
                self.high_mark = self.low_mark + high
            DEDENT
        DEDENT
        if low is not None :
        INDENT
            if self.high_mark is not None :
            INDENT
                self.low_mark = min(self.high_mark, self.low_mark + low)
            DEDENT
            else :
            INDENT
                self.low_mark = self.low_mark + low
            DEDENT
        DEDENT
    DEDENT
    def clear_limits(self) :
    INDENT
        self.low_mark, self.high_mark = 0, None
    DEDENT
    def can_filter(self) :
    INDENT
        return not self.low_mark and self.high_mark is None
    DEDENT
    def clear_select_fields(self) :
    INDENT
        self.select = []
        self.select_fields = []
    DEDENT
    def add_fields(self, field_names, allow_m2m = True) :
    INDENT
        alias = self.get_initial_alias()
        opts = self.get_meta()
        try :
        INDENT
            for name in field_names :
            INDENT
                field, target, u2, joins, u3, u4 = self.setup_joins(
                    name.split(LOOKUP_SEP), opts, alias, False, allow_m2m,
                    True)
                final_alias = joins [- 1]
                col = target.column
                if len(joins) > 1 :
                INDENT
                    join = self.alias_map [final_alias]
                    if col == join [RHS_JOIN_COL] :
                    INDENT
                        self.unref_alias(final_alias)
                        final_alias = join [LHS_ALIAS]
                        col = join [LHS_JOIN_COL]
                        joins = joins [: - 1]
                    DEDENT
                DEDENT
                self.promote_alias_chain(joins [1 :])
                self.select.append((final_alias, col))
                self.select_fields.append(field)
            DEDENT
        DEDENT
        except MultiJoin :
        INDENT
            raise FieldError("Invalid field name: '%s'" % name)
        DEDENT
        except FieldError :
        INDENT
            names = opts.get_all_field_names() + self.extra.keys() + self.aggregate_select.keys()
            names.sort()
            raise FieldError("Cannot resolve keyword %r into field. "
                "Choices are: %s" % (name, ", ".join(names)))
        DEDENT
        self.remove_inherited_models()
    DEDENT
    def add_ordering(self, * ordering) :
    INDENT
        errors = []
        for item in ordering :
        INDENT
            if not ORDER_PATTERN.match(item) :
            INDENT
                errors.append(item)
            DEDENT
        DEDENT
        if errors :
        INDENT
            raise FieldError('Invalid order_by arguments: %s' % errors)
        DEDENT
        if ordering :
        INDENT
            self.order_by.extend(ordering)
        DEDENT
        else :
        INDENT
            self.default_ordering = False
        DEDENT
    DEDENT
    def clear_ordering(self, force_empty = False) :
    INDENT
        self.order_by = []
        self.extra_order_by = ()
        if force_empty :
        INDENT
            self.default_ordering = False
        DEDENT
    DEDENT
    def set_group_by(self) :
    INDENT
        self.group_by = []
        for sel in self.select :
        INDENT
            self.group_by.append(sel)
        DEDENT
    DEDENT
    def add_count_column(self) :
    INDENT
        if not self.distinct :
        INDENT
            if not self.select :
            INDENT
                count = self.aggregates_module.Count('*', is_summary = True)
            DEDENT
            else :
            INDENT
                assert len(self.select) == 1, "Cannot add count col with multiple cols in 'select': %r" % self.select
                count = self.aggregates_module.Count(self.select [0])
            DEDENT
        DEDENT
        else :
        INDENT
            opts = self.model._meta
            if not self.select :
            INDENT
                count = self.aggregates_module.Count((self.join((None, opts.db_table, None, None)), opts.pk.column),
                    is_summary = True, distinct = True)
            DEDENT
            else :
            INDENT
                assert len(self.select) == 1, "Cannot add count col with multiple cols in 'select'."
                count = self.aggregates_module.Count(self.select [0], distinct = True)

            DEDENT
            self.distinct = False

        DEDENT
        self.aggregates = {None : count}
        self.set_aggregate_mask(None)
        self.group_by = None
    DEDENT
    def add_select_related(self, fields) :
    INDENT
        field_dict = {}
        for field in fields :
        INDENT
            d = field_dict
            for part in field.split(LOOKUP_SEP) :
            INDENT
                d = d.setdefault(part, {})
            DEDENT
        DEDENT
        self.select_related = field_dict
        self.related_select_cols = []
        self.related_select_fields = []
    DEDENT
    def add_extra(self, select, select_params, where, params, tables, order_by) :
    INDENT
        if select :
        INDENT
            select_pairs = SortedDict()
            if select_params :
            INDENT
                param_iter = iter(select_params)
            DEDENT
            else :
            INDENT
                param_iter = iter([])
            DEDENT
            for name, entry in select.items() :
            INDENT
                entry = force_unicode(entry)
                entry_params = []
                pos = entry.find("%s")
                while pos ! = - 1 :
                INDENT
                    entry_params.append(param_iter.next())
                    pos = entry.find("%s", pos + 2)
                DEDENT
                select_pairs [name] = (entry, entry_params)
            DEDENT
            self.extra.update(select_pairs)
        DEDENT
        if where :
        INDENT
            self.extra_where += tuple(where)
        DEDENT
        if params :
        INDENT
            self.extra_params += tuple(params)
        DEDENT
        if tables :
        INDENT
            self.extra_tables += tuple(tables)
        DEDENT
        if order_by :
        INDENT
            self.extra_order_by = order_by
        DEDENT
    DEDENT
    def clear_deferred_loading(self) :
    INDENT
        self.deferred_loading = (set(), True)
    DEDENT
    def add_deferred_loading(self, field_names) :
    INDENT
        existing, defer = self.deferred_loading
        if defer :
        INDENT
            self.deferred_loading = existing.union(field_names), True
        DEDENT
        else :
        INDENT
            self.deferred_loading = existing.difference(field_names), False
        DEDENT
    DEDENT
    def add_immediate_loading(self, field_names) :
    INDENT
        existing, defer = self.deferred_loading
        if defer :
        INDENT
            self.deferred_loading = set(field_names).difference(existing), False
        DEDENT
        else :
        INDENT
            self.deferred_loading = set(field_names), False
        DEDENT
    DEDENT
    def get_loaded_field_names(self) :
    INDENT
        collection = {}
        self.deferred_to_data(collection, self.get_loaded_field_names_cb)
        return collection
    DEDENT
    def get_loaded_field_names_cb(self, target, model, fields) :
    INDENT
        target [model] = set([f.name for f in fields])
    DEDENT
    def set_aggregate_mask(self, names) :
    INDENT
        "Set the mask of aggregates that will actually be returned by the SELECT"
        if names is None :
        INDENT
            self.aggregate_select_mask = None
        DEDENT
        else :
        INDENT
            self.aggregate_select_mask = set(names)
        DEDENT
        self._aggregate_select_cache = None
    DEDENT
    def set_extra_mask(self, names) :
    INDENT
        if names is None :
        INDENT
            self.extra_select_mask = None
        DEDENT
        else :
        INDENT
            self.extra_select_mask = set(names)
        DEDENT
        self._extra_select_cache = None
    DEDENT
    def _aggregate_select(self) :
    INDENT
        if self._aggregate_select_cache is not None :
        INDENT
            return self._aggregate_select_cache
        DEDENT
        elif self.aggregate_select_mask is not None :
        INDENT
            self._aggregate_select_cache = SortedDict([
                    (k, v) for k, v in self.aggregates.items()
                    if k in self.aggregate_select_mask
                    ])
            return self._aggregate_select_cache
        DEDENT
        else :
        INDENT
            return self.aggregates
        DEDENT
    DEDENT
    aggregate_select = property(_aggregate_select)
    def _extra_select(self) :
    INDENT
        if self._extra_select_cache is not None :
        INDENT
            return self._extra_select_cache
        DEDENT
        elif self.extra_select_mask is not None :
        INDENT
            self._extra_select_cache = SortedDict([
                    (k, v) for k, v in self.extra.items()
                    if k in self.extra_select_mask
                    ])
            return self._extra_select_cache
        DEDENT
        else :
        INDENT
            return self.extra
        DEDENT
    DEDENT
    extra_select = property(_extra_select)
    def set_start(self, start) :
    INDENT
        opts = self.model._meta
        alias = self.get_initial_alias()
        field, col, opts, joins, last, extra = self.setup_joins(
            start.split(LOOKUP_SEP), opts, alias, False)
        select_col = self.alias_map [joins [1]] [LHS_JOIN_COL]
        select_alias = alias

        for alias in joins :
        INDENT
            self.unref_alias(alias)

        DEDENT
        for alias in joins [1 :] :
        INDENT
            join_info = self.alias_map [alias]
            if (join_info [LHS_JOIN_COL] ! = select_col
                or join_info [JOIN_TYPE] ! = self.INNER) :
            INDENT
                break
            DEDENT
            self.unref_alias(select_alias)
            select_alias = join_info [RHS_ALIAS]
            select_col = join_info [RHS_JOIN_COL]
        DEDENT
        self.select = [(select_alias, select_col)]
        self.remove_inherited_models()

    DEDENT
DEDENT
def get_order_dir(field, default = 'ASC') :
INDENT
    dirn = ORDER_DIR [default]
    if field [0] == '-' :
    INDENT
        return field [1 :], dirn [1]
    DEDENT
    return field, dirn [0]

DEDENT
def setup_join_cache(sender, ** kwargs) :
INDENT
    sender._meta._join_cache = {}
DEDENT
signals.class_prepared.connect(setup_join_cache)
def add_to_dict(data, key, value) :
INDENT
    if key in data :
    INDENT
        data [key].add(value)
    DEDENT
    else :
    INDENT
        data [key] = set([value])
    DEDENT
DEDENT
def get_proxied_model(opts) :
INDENT
    int_opts = opts
    proxied_model = None
    while int_opts.proxy :
    INDENT
        proxied_model = int_opts.proxy_for_model
        int_opts = proxied_model._meta
    DEDENT
    return proxied_model
DEDENT
</source>
<source file="systems/py/Django/trunk/django/db/models/sql/subqueries.py.pyindent" startline="1" endline="251">
from django.core.exceptions import FieldError
from django.db import connections
from django.db.models.sql.constants import *
from django.db.models.sql.datastructures import Date
from django.db.models.sql.expressions import SQLEvaluator
from django.db.models.sql.query import Query
from django.db.models.sql.where import AND, Constraint
__all__ = ['DeleteQuery', 'UpdateQuery', 'InsertQuery', 'DateQuery',
    'AggregateQuery']
class DeleteQuery(Query) :
INDENT
    compiler = 'SQLDeleteCompiler'
    def do_query(self, table, where, using) :
    INDENT
        self.tables = [table]
        self.where = where
        self.get_compiler(using).execute_sql(None)
    DEDENT
    def delete_batch_related(self, pk_list, using) :
    INDENT
        from django.contrib.contenttypes import generic
        cls = self.model
        for related in cls._meta.get_all_related_many_to_many_objects() :
        INDENT
            if not isinstance(related.field, generic.GenericRelation) :
            INDENT
                for offset in range(0, len(pk_list), GET_ITERATOR_CHUNK_SIZE) :
                INDENT
                    where = self.where_class()
                    where.add((Constraint(None,
                                related.field.m2m_reverse_name(), related.field),
                            'in',
                            pk_list [offset : offset + GET_ITERATOR_CHUNK_SIZE]),
                        AND)
                    self.do_query(related.field.m2m_db_table(), where, using = using)
                DEDENT
            DEDENT
        DEDENT
        for f in cls._meta.many_to_many :
        INDENT
            w1 = self.where_class()
            if isinstance(f, generic.GenericRelation) :
            INDENT
                from django.contrib.contenttypes.models import ContentType
                field = f.rel.to._meta.get_field(f.content_type_field_name)
                w1.add((Constraint(None, field.column, field), 'exact',
                        ContentType.objects.get_for_model(cls).id), AND)
            DEDENT
            for offset in range(0, len(pk_list), GET_ITERATOR_CHUNK_SIZE) :
            INDENT
                where = self.where_class()
                where.add((Constraint(None, f.m2m_column_name(), f), 'in',
                        pk_list [offset : offset + GET_ITERATOR_CHUNK_SIZE]),
                    AND)
                if w1 :
                INDENT
                    where.add(w1, AND)
                DEDENT
                self.do_query(f.m2m_db_table(), where, using = using)
            DEDENT
        DEDENT
    DEDENT
    def delete_batch(self, pk_list, using) :
    INDENT
        for offset in range(0, len(pk_list), GET_ITERATOR_CHUNK_SIZE) :
        INDENT
            where = self.where_class()
            field = self.model._meta.pk
            where.add((Constraint(None, field.column, field), 'in',
                    pk_list [offset : offset + GET_ITERATOR_CHUNK_SIZE]), AND)
            self.do_query(self.model._meta.db_table, where, using = using)
        DEDENT
    DEDENT
DEDENT
class UpdateQuery(Query) :
INDENT
    compiler = 'SQLUpdateCompiler'
    def __init__(self, * args, ** kwargs) :
    INDENT
        super(UpdateQuery, self).__init__(* args, ** kwargs)
        self._setup_query()
    DEDENT
    def _setup_query(self) :
    INDENT
        self.values = []
        self.related_ids = None
        if not hasattr(self, 'related_updates') :
        INDENT
            self.related_updates = {}
        DEDENT
    DEDENT
    def clone(self, klass = None, ** kwargs) :
    INDENT
        return super(UpdateQuery, self).clone(klass,
            related_updates = self.related_updates.copy(), ** kwargs)

    DEDENT
    def clear_related(self, related_field, pk_list, using) :
    INDENT
        for offset in range(0, len(pk_list), GET_ITERATOR_CHUNK_SIZE) :
        INDENT
            self.where = self.where_class()
            f = self.model._meta.pk
            self.where.add((Constraint(None, f.column, f), 'in',
                    pk_list [offset : offset + GET_ITERATOR_CHUNK_SIZE]),
                AND)
            self.values = [(related_field, None, None)]
            self.get_compiler(using).execute_sql(None)
        DEDENT
    DEDENT
    def add_update_values(self, values) :
    INDENT
        values_seq = []
        for name, val in values.iteritems() :
        INDENT
            field, model, direct, m2m = self.model._meta.get_field_by_name(name)
            if not direct or m2m :
            INDENT
                raise FieldError('Cannot update model field %r (only non-relations and foreign keys permitted).' % field)
            DEDENT
            if model :
            INDENT
                self.add_related_update(model, field, val)
                continue
            DEDENT
            values_seq.append((field, model, val))
        DEDENT
        return self.add_update_fields(values_seq)
    DEDENT
    def add_update_fields(self, values_seq) :
    INDENT
        self.values.extend(values_seq)
    DEDENT
    def add_related_update(self, model, field, value) :
    INDENT
        try :
        INDENT
            self.related_updates [model].append((field, None, value))
        DEDENT
        except KeyError :
        INDENT
            self.related_updates [model] = [(field, None, value)]
        DEDENT
    DEDENT
    def get_related_updates(self) :
    INDENT
        if not self.related_updates :
        INDENT
            return []
        DEDENT
        result = []
        for model, values in self.related_updates.iteritems() :
        INDENT
            query = UpdateQuery(model)
            query.values = values
            if self.related_ids :
            INDENT
                query.add_filter(('pk__in', self.related_ids))
            DEDENT
            result.append(query)
        DEDENT
        return result
    DEDENT
DEDENT
class InsertQuery(Query) :
INDENT
    compiler = 'SQLInsertCompiler'
    def __init__(self, * args, ** kwargs) :
    INDENT
        super(InsertQuery, self).__init__(* args, ** kwargs)
        self.columns = []
        self.values = []
        self.params = ()
    DEDENT
    def clone(self, klass = None, ** kwargs) :
    INDENT
        extras = {
            'columns' : self.columns [:],
            'values' : self.values [:],
            'params' : self.params}
        extras.update(kwargs)
        return super(InsertQuery, self).clone(klass, ** extras)
    DEDENT
    def insert_values(self, insert_values, raw_values = False) :
    INDENT
        placeholders, values = [], []
        for field, val in insert_values :
        INDENT
            placeholders.append((field, val))
            self.columns.append(field.column)
            values.append(val)
        DEDENT
        if raw_values :
        INDENT
            self.values.extend([(None, v) for v in values])
        DEDENT
        else :
        INDENT
            self.params += tuple(values)
            self.values.extend(placeholders)
        DEDENT
    DEDENT
DEDENT
class DateQuery(Query) :
INDENT
    compiler = 'SQLDateCompiler'
    def add_date_select(self, field, lookup_type, order = 'ASC') :
    INDENT
        result = self.setup_joins([field.name], self.get_meta(),
            self.get_initial_alias(), False)
        alias = result [3] [- 1]
        select = Date((alias, field.column), lookup_type)
        self.select = [select]
        self.select_fields = [None]
        self.select_related = False
        self.set_extra_mask([])
        self.distinct = True
        self.order_by = order == 'ASC' and [1] or [- 1]
    DEDENT
DEDENT
class AggregateQuery(Query) :
INDENT
    compiler = 'SQLAggregateCompiler'
    def add_subquery(self, query, using) :
    INDENT
        self.subquery, self.sub_params = query.get_compiler(using).as_sql(with_col_aliases = True)
    DEDENT
DEDENT
</source>
<source file="systems/py/Django/trunk/django/db/models/sql/where.py.pyindent" startline="1" endline="297">
import datetime
from django.utils import tree
from django.db.models.fields import Field
from django.db.models.query_utils import QueryWrapper
from datastructures import EmptyResultSet, FullResultSet
AND = 'AND'
OR = 'OR'
class EmptyShortCircuit(Exception) :
INDENT
    pass
DEDENT
class WhereNode(tree.Node) :
INDENT
    default = AND
    def add(self, data, connector) :
    INDENT
        if not isinstance(data, (list, tuple)) :
        INDENT
            super(WhereNode, self).add(data, connector)
            return
        DEDENT
        obj, lookup_type, value = data
        if hasattr(value, '__iter__') and hasattr(value, 'next') :
        INDENT
            value = list(value)

        DEDENT
        if isinstance(value, datetime.datetime) :
        INDENT
            annotation = datetime.datetime
        DEDENT
        elif hasattr(value, 'value_annotation') :
        INDENT
            annotation = value.value_annotation
        DEDENT
        else :
        INDENT
            annotation = bool(value)
        DEDENT
        if hasattr(obj, "prepare") :
        INDENT
            value = obj.prepare(lookup_type, value)
            super(WhereNode, self).add((obj, lookup_type, annotation, value),
                connector)
            return
        DEDENT
        super(WhereNode, self).add((obj, lookup_type, annotation, value),
            connector)
    DEDENT
    def as_sql(self, qn, connection) :
    INDENT
        if not self.children :
        INDENT
            return None, []
        DEDENT
        result = []
        result_params = []
        empty = True
        for child in self.children :
        INDENT
            try :
            INDENT
                if hasattr(child, 'as_sql') :
                INDENT
                    sql, params = child.as_sql(qn = qn, connection = connection)
                DEDENT
                else :
                INDENT
                    sql, params = self.make_atom(child, qn, connection)
                DEDENT
            DEDENT
            except EmptyResultSet :
            INDENT
                if self.connector == AND and not self.negated :
                INDENT
                    raise
                DEDENT
                elif self.negated :
                INDENT
                    empty = False
                DEDENT
                continue
            DEDENT
            except FullResultSet :
            INDENT
                if self.connector == OR :
                INDENT
                    if self.negated :
                    INDENT
                        empty = True
                        break
                    DEDENT
                    return '', []
                DEDENT
                if self.negated :
                INDENT
                    empty = True
                DEDENT
                continue
            DEDENT
            empty = False
            if sql :
            INDENT
                result.append(sql)
                result_params.extend(params)
            DEDENT
        DEDENT
        if empty :
        INDENT
            raise EmptyResultSet
        DEDENT
        conn = ' %s ' % self.connector
        sql_string = conn.join(result)
        if sql_string :
        INDENT
            if self.negated :
            INDENT
                sql_string = 'NOT (%s)' % sql_string
            DEDENT
            elif len(self.children) ! = 1 :
            INDENT
                sql_string = '(%s)' % sql_string
            DEDENT
        DEDENT
        return sql_string, result_params
    DEDENT
    def make_atom(self, child, qn, connection) :
    INDENT
        lvalue, lookup_type, value_annot, params_or_value = child
        if hasattr(lvalue, 'process') :
        INDENT
            try :
            INDENT
                lvalue, params = lvalue.process(lookup_type, params_or_value, connection)
            DEDENT
            except EmptyShortCircuit :
            INDENT
                raise EmptyResultSet
            DEDENT
        DEDENT
        else :
        INDENT
            params = Field().get_db_prep_lookup(lookup_type, params_or_value,
                connection = connection, prepared = True)
        DEDENT
        if isinstance(lvalue, tuple) :
        INDENT
            field_sql = self.sql_for_columns(lvalue, qn, connection)
        DEDENT
        else :
        INDENT
            field_sql = lvalue.as_sql(qn, connection)
        DEDENT
        if value_annot is datetime.datetime :
        INDENT
            cast_sql = connection.ops.datetime_cast_sql()
        DEDENT
        else :
        INDENT
            cast_sql = '%s'
        DEDENT
        if hasattr(params, 'as_sql') :
        INDENT
            extra, params = params.as_sql(qn, connection)
            cast_sql = ''
        DEDENT
        else :
        INDENT
            extra = ''
        DEDENT
        if (len(params) == 1 and params [0] == '' and lookup_type == 'exact'
            and connection.features.interprets_empty_strings_as_nulls) :
        INDENT
            lookup_type = 'isnull'
            value_annot = True
        DEDENT
        if lookup_type in connection.operators :
        INDENT
            format = "%s %%s %%s" % (connection.ops.lookup_cast(lookup_type),)
            return (format % (field_sql,
                    connection.operators [lookup_type] % cast_sql,
                    extra), params)
        DEDENT
        if lookup_type == 'in' :
        INDENT
            if not value_annot :
            INDENT
                raise EmptyResultSet
            DEDENT
            if extra :
            INDENT
                return ('%s IN %s' % (field_sql, extra), params)
            DEDENT
            return ('%s IN (%s)' % (field_sql, ', '.join(['%s'] * len(params))),
                params)
        DEDENT
        elif lookup_type in ('range', 'year') :
        INDENT
            return ('%s BETWEEN %%s and %%s' % field_sql, params)
        DEDENT
        elif lookup_type in ('month', 'day', 'week_day') :
        INDENT
            return ('%s = %%s' % connection.ops.date_extract_sql(lookup_type, field_sql),
                params)
        DEDENT
        elif lookup_type == 'isnull' :
        INDENT
            return ('%s IS %sNULL' % (field_sql,
                    (not value_annot and 'NOT ' or '')), ())
        DEDENT
        elif lookup_type == 'search' :
        INDENT
            return (connection.ops.fulltext_search_sql(field_sql), params)
        DEDENT
        elif lookup_type in ('regex', 'iregex') :
        INDENT
            return connection.ops.regex_lookup(lookup_type) % (field_sql, cast_sql), params
        DEDENT
        raise TypeError('Invalid lookup_type: %r' % lookup_type)
    DEDENT
    def sql_for_columns(self, data, qn, connection) :
    INDENT
        table_alias, name, db_type = data
        if table_alias :
        INDENT
            lhs = '%s.%s' % (qn(table_alias), qn(name))
        DEDENT
        else :
        INDENT
            lhs = qn(name)
        DEDENT
        return connection.ops.field_cast_sql(db_type) % lhs
    DEDENT
    def relabel_aliases(self, change_map, node = None) :
    INDENT
        if not node :
        INDENT
            node = self
        DEDENT
        for pos, child in enumerate(node.children) :
        INDENT
            if hasattr(child, 'relabel_aliases') :
            INDENT
                child.relabel_aliases(change_map)
            DEDENT
            elif isinstance(child, tree.Node) :
            INDENT
                self.relabel_aliases(change_map, child)
            DEDENT
            else :
            INDENT
                if isinstance(child [0], (list, tuple)) :
                INDENT
                    elt = list(child [0])
                    if elt [0] in change_map :
                    INDENT
                        elt [0] = change_map [elt [0]]
                        node.children [pos] = (tuple(elt),) + child [1 :]
                    DEDENT
                DEDENT
                else :
                INDENT
                    child [0].relabel_aliases(change_map)

                DEDENT
                if hasattr(child [3], 'relabel_aliases') :
                INDENT
                    child [3].relabel_aliases(change_map)
                DEDENT
            DEDENT
        DEDENT
    DEDENT
DEDENT
class EverythingNode(object) :
INDENT
    def as_sql(self, qn = None, connection = None) :
    INDENT
        raise FullResultSet
    DEDENT
    def relabel_aliases(self, change_map, node = None) :
    INDENT
        return
    DEDENT
DEDENT
class NothingNode(object) :
INDENT
    def as_sql(self, qn = None, connection = None) :
    INDENT
        raise EmptyResultSet
    DEDENT
    def relabel_aliases(self, change_map, node = None) :
    INDENT
        return
    DEDENT
DEDENT
class Constraint(object) :
INDENT
    def __init__(self, alias, col, field) :
    INDENT
        self.alias, self.col, self.field = alias, col, field
    DEDENT
    def prepare(self, lookup_type, value) :
    INDENT
        if self.field :
        INDENT
            return self.field.get_prep_lookup(lookup_type, value)
        DEDENT
        return value
    DEDENT
    def process(self, lookup_type, value, connection) :
    INDENT
        from django.db.models.base import ObjectDoesNotExist
        try :
        INDENT
            if self.field :
            INDENT
                params = self.field.get_db_prep_lookup(lookup_type, value,
                    connection = connection, prepared = True)
                db_type = self.field.db_type(connection = connection)
            DEDENT
            else :
            INDENT
                params = Field().get_db_prep_lookup(lookup_type, value,
                    connection = connection, prepared = True)
                db_type = None
            DEDENT
        DEDENT
        except ObjectDoesNotExist :
        INDENT
            raise EmptyShortCircuit
        DEDENT
        return (self.alias, self.col, db_type), params
    DEDENT
    def relabel_aliases(self, change_map) :
    INDENT
        if self.alias in change_map :
        INDENT
            self.alias = change_map [self.alias]
        DEDENT
    DEDENT
DEDENT
</source>
<source file="systems/py/Django/trunk/django/db/models/sql/constants.py.pyindent" startline="1" endline="37">
import re
QUERY_TERMS = dict([(x, None) for x in (
            'exact', 'iexact', 'contains', 'icontains', 'gt', 'gte', 'lt', 'lte', 'in',
            'startswith', 'istartswith', 'endswith', 'iendswith', 'range', 'year',
            'month', 'day', 'week_day', 'isnull', 'search', 'regex', 'iregex',
            )])

GET_ITERATOR_CHUNK_SIZE = 100

LOOKUP_SEP = '__'

TABLE_NAME = 0
RHS_ALIAS = 1
JOIN_TYPE = 2
LHS_ALIAS = 3
LHS_JOIN_COL = 4
RHS_JOIN_COL = 5
NULLABLE = 6

MULTI = 'multi'
SINGLE = 'single'
ORDER_PATTERN = re.compile(r'\?|[-+]?[.\w]+$')
ORDER_DIR = {
    'ASC' : ('ASC', 'DESC'),
    'DESC' : ('DESC', 'ASC')}

</source>
<source file="systems/py/Django/trunk/django/db/models/sql/expressions.py.pyindent" startline="1" endline="85">
from django.core.exceptions import FieldError
from django.db.models.fields import FieldDoesNotExist
from django.db.models.sql.constants import LOOKUP_SEP
class SQLEvaluator(object) :
INDENT
    def __init__(self, expression, query, allow_joins = True) :
    INDENT
        self.expression = expression
        self.opts = query.get_meta()
        self.cols = {}
        self.contains_aggregate = False
        self.expression.prepare(self, query, allow_joins)
    DEDENT
    def prepare(self) :
    INDENT
        return self
    DEDENT
    def as_sql(self, qn, connection) :
    INDENT
        return self.expression.evaluate(self, qn, connection)
    DEDENT
    def relabel_aliases(self, change_map) :
    INDENT
        for node, col in self.cols.items() :
        INDENT
            self.cols [node] = (change_map.get(col [0], col [0]), col [1])

        DEDENT
    DEDENT
    def prepare_node(self, node, query, allow_joins) :
    INDENT
        for child in node.children :
        INDENT
            if hasattr(child, 'prepare') :
            INDENT
                child.prepare(self, query, allow_joins)
            DEDENT
        DEDENT
    DEDENT
    def prepare_leaf(self, node, query, allow_joins) :
    INDENT
        if not allow_joins and LOOKUP_SEP in node.name :
        INDENT
            raise FieldError("Joined field references are not permitted in this query")
        DEDENT
        field_list = node.name.split(LOOKUP_SEP)
        if (len(field_list) == 1 and
            node.name in query.aggregate_select.keys()) :
        INDENT
            self.contains_aggregate = True
            self.cols [node] = query.aggregate_select [node.name]
        DEDENT
        else :
        INDENT
            try :
            INDENT
                field, source, opts, join_list, last, _ = query.setup_joins(
                    field_list, query.get_meta(),
                    query.get_initial_alias(), False)
                col, _, join_list = query.trim_joins(source, join_list, last, False)
                self.cols [node] = (join_list [- 1], col)
            DEDENT
            except FieldDoesNotExist :
            INDENT
                raise FieldError("Cannot resolve keyword %r into field. "
                    "Choices are: %s" % (self.name,
                        [f.name for f in self.opts.fields]))
            DEDENT
        DEDENT
    DEDENT
    def evaluate_node(self, node, qn, connection) :
    INDENT
        expressions = []
        expression_params = []
        for child in node.children :
        INDENT
            if hasattr(child, 'evaluate') :
            INDENT
                sql, params = child.evaluate(self, qn, connection)
            DEDENT
            else :
            INDENT
                sql, params = '%s', (child,)
            DEDENT
            if len(getattr(child, 'children', [])) > 1 :
            INDENT
                format = '(%s)'
            DEDENT
            else :
            INDENT
                format = '%s'
            DEDENT
            if sql :
            INDENT
                expressions.append(format % sql)
                expression_params.extend(params)
            DEDENT
        DEDENT
        return connection.ops.combine_expression(node.connector, expressions), expression_params
    DEDENT
    def evaluate_leaf(self, node, qn, connection) :
    INDENT
        col = self.cols [node]
        if hasattr(col, 'as_sql') :
        INDENT
            return col.as_sql(qn, connection), ()
        DEDENT
        else :
        INDENT
            return '%s.%s' % (qn(col [0]), qn(col [1])), ()
        DEDENT
    DEDENT
DEDENT
</source>
<source file="systems/py/Django/trunk/django/db/models/sql/__init__.py.pyindent" startline="1" endline="7">
from query import *
from subqueries import *
from where import AND, OR
from datastructures import EmptyResultSet
__all__ = ['Query', 'AND', 'OR', 'EmptyResultSet']
</source>
<source file="systems/py/Django/trunk/django/db/models/sql/aggregates.py.pyindent" startline="1" endline="128">
class AggregateField(object) :
INDENT
    def __init__(self, internal_type) :
    INDENT
        self.internal_type = internal_type
    DEDENT
    def get_internal_type(self) :
    INDENT
        return self.internal_type
    DEDENT
DEDENT
ordinal_aggregate_field = AggregateField('IntegerField')
computed_aggregate_field = AggregateField('FloatField')
class Aggregate(object) :
INDENT
    is_ordinal = False
    is_computed = False
    sql_template = '%(function)s(%(field)s)'
    def __init__(self, col, source = None, is_summary = False, ** extra) :
    INDENT
        self.col = col
        self.source = source
        self.is_summary = is_summary
        self.extra = extra

        tmp = self
        while tmp and isinstance(tmp, Aggregate) :
        INDENT
            if getattr(tmp, 'is_ordinal', False) :
            INDENT
                tmp = ordinal_aggregate_field
            DEDENT
            elif getattr(tmp, 'is_computed', False) :
            INDENT
                tmp = computed_aggregate_field
            DEDENT
            else :
            INDENT
                tmp = tmp.source
            DEDENT
        DEDENT
        self.field = tmp
    DEDENT
    def relabel_aliases(self, change_map) :
    INDENT
        if isinstance(self.col, (list, tuple)) :
        INDENT
            self.col = (change_map.get(self.col [0], self.col [0]), self.col [1])
        DEDENT
    DEDENT
    def as_sql(self, qn, connection) :
    INDENT
        "Return the aggregate, rendered as SQL."
        if hasattr(self.col, 'as_sql') :
        INDENT
            field_name = self.col.as_sql(qn, connection)
        DEDENT
        elif isinstance(self.col, (list, tuple)) :
        INDENT
            field_name = '.'.join([qn(c) for c in self.col])
        DEDENT
        else :
        INDENT
            field_name = self.col
        DEDENT
        params = {
            'function' : self.sql_function,
            'field' : field_name}
        params.update(self.extra)
        return self.sql_template % params

    DEDENT
DEDENT
class Avg(Aggregate) :
INDENT
    is_computed = True
    sql_function = 'AVG'
DEDENT
class Count(Aggregate) :
INDENT
    is_ordinal = True
    sql_function = 'COUNT'
    sql_template = '%(function)s(%(distinct)s%(field)s)'
    def __init__(self, col, distinct = False, ** extra) :
    INDENT
        super(Count, self).__init__(col, distinct = distinct and 'DISTINCT ' or '', ** extra)
    DEDENT
DEDENT
class Max(Aggregate) :
INDENT
    sql_function = 'MAX'
DEDENT
class Min(Aggregate) :
INDENT
    sql_function = 'MIN'
DEDENT
class StdDev(Aggregate) :
INDENT
    is_computed = True
    def __init__(self, col, sample = False, ** extra) :
    INDENT
        super(StdDev, self).__init__(col, ** extra)
        self.sql_function = sample and 'STDDEV_SAMP' or 'STDDEV_POP'
    DEDENT
DEDENT
class Sum(Aggregate) :
INDENT
    sql_function = 'SUM'
DEDENT
class Variance(Aggregate) :
INDENT
    is_computed = True
    def __init__(self, col, sample = False, ** extra) :
    INDENT
        super(Variance, self).__init__(col, ** extra)
        self.sql_function = sample and 'VAR_SAMP' or 'VAR_POP'
    DEDENT
DEDENT
</source>
<source file="systems/py/Django/trunk/django/db/models/sql/datastructures.py.pyindent" startline="1" endline="47">
class EmptyResultSet(Exception) :
INDENT
    pass
DEDENT
class FullResultSet(Exception) :
INDENT
    pass
DEDENT
class MultiJoin(Exception) :
INDENT
    def __init__(self, level) :
    INDENT
        self.level = level
    DEDENT
DEDENT
class Empty(object) :
INDENT
    pass
DEDENT
class RawValue(object) :
INDENT
    def __init__(self, value) :
    INDENT
        self.value = value
    DEDENT
DEDENT
class Date(object) :
INDENT
    def __init__(self, col, lookup_type) :
    INDENT
        self.col = col
        self.lookup_type = lookup_type
    DEDENT
    def relabel_aliases(self, change_map) :
    INDENT
        c = self.col
        if isinstance(c, (list, tuple)) :
        INDENT
            self.col = (change_map.get(c [0], c [0]), c [1])
        DEDENT
    DEDENT
    def as_sql(self, qn, connection) :
    INDENT
        if isinstance(self.col, (list, tuple)) :
        INDENT
            col = '%s.%s' % tuple([qn(c) for c in self.col])
        DEDENT
        else :
        INDENT
            col = self.col
        DEDENT
        return connection.ops.date_trunc_sql(self.lookup_type, col)
    DEDENT
DEDENT
</source>
<source file="systems/py/Django/trunk/django/db/utils.py.pyindent" startline="1" endline="84">
import inspect
import os
from django.conf import settings
from django.core.exceptions import ImproperlyConfigured
from django.utils.importlib import import_module
def load_backend(backend_name) :
INDENT
    try :
    INDENT
        module = import_module('.base', 'django.db.backends.%s' % backend_name)
        import warnings
        warnings.warn(
            "Short names for DATABASE_ENGINE are deprecated; prepend with 'django.db.backends.'",
            PendingDeprecationWarning)
        return module
    DEDENT
    except ImportError, e :
    INDENT
        try :
        INDENT
            return import_module('.base', backend_name)
        DEDENT
        except ImportError, e_user :
        INDENT
            backend_dir = os.path.join(os.path.dirname(__file__), 'backends')
            try :
            INDENT
                available_backends = [f for f in os.listdir(backend_dir)
                    if os.path.isdir(os.path.join(backend_dir, f))
                    and not f.startswith('.')]
            DEDENT
            except EnvironmentError :
            INDENT
                available_backends = []
            DEDENT
            available_backends.sort()
            if backend_name not in available_backends :
            INDENT
                error_msg = ("%r isn't an available database backend. \n" +
                    "Try using django.db.backends.XXX, where XXX is one of:\n    %s\n" +
                    "Error was: %s") % (backend_name, ", ".join(map(repr, available_backends)), e_user)
                raise ImproperlyConfigured(error_msg)
            DEDENT
            else :
            INDENT
                raise
            DEDENT
        DEDENT
    DEDENT
DEDENT
class ConnectionDoesNotExist(Exception) :
INDENT
    pass
DEDENT
class ConnectionHandler(object) :
INDENT
    def __init__(self, databases) :
    INDENT
        self.databases = databases
        self._connections = {}
    DEDENT
    def ensure_defaults(self, alias) :
    INDENT
        try :
        INDENT
            conn = self.databases [alias]
        DEDENT
        except KeyError :
        INDENT
            raise ConnectionDoesNotExist("The connection %s doesn't exist" % alias)
        DEDENT
        conn.setdefault('ENGINE', 'django.db.backends.dummy')
        if conn ['ENGINE'] == 'django.db.backends.' :
        INDENT
            conn ['ENGINE'] = 'django.db.backends.dummy'
        DEDENT
        conn.setdefault('OPTIONS', {})
        conn.setdefault('TEST_CHARSET', None)
        conn.setdefault('TEST_COLLATION', None)
        conn.setdefault('TEST_NAME', None)
        conn.setdefault('TIME_ZONE', settings.TIME_ZONE)
        for setting in ('NAME', 'USER', 'PASSWORD', 'HOST', 'PORT') :
        INDENT
            conn.setdefault(setting, '')
        DEDENT
    DEDENT
    def __getitem__(self, alias) :
    INDENT
        if alias in self._connections :
        INDENT
            return self._connections [alias]
        DEDENT
        self.ensure_defaults(alias)
        db = self.databases [alias]
        backend = load_backend(db ['ENGINE'])
        conn = backend.DatabaseWrapper(db, alias)
        self._connections [alias] = conn
        return conn
    DEDENT
    def __iter__(self) :
    INDENT
        return iter(self.databases)
    DEDENT
    def all(self) :
    INDENT
        return [self [alias] for alias in self]
    DEDENT
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/csrf.py.pyindent" startline="1" endline="70">
from django.http import HttpResponseForbidden
from django.template import Context, Template
from django.conf import settings
CSRF_FAILRE_TEMPLATE = """
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>403 Forbidden</title>
</head>
<body>
  <h1>403 Forbidden</h1>
  <p>CSRF verification failed. Request aborted.</p>
  {% if DEBUG %}
  <h2>Help</h2>
    {% if reason %}
    <p>Reason given for failure:</p>
    <pre>
    {{ reason }}
    </pre>
    {% endif %}

  <p>In general, this can occur when there is a genuine Cross Site Request Forgery, or when
  <a
  href='http://docs.djangoproject.com/en/dev/ref/contrib/csrf/#ref-contrib-csrf'>Django's
  CSRF mechanism</a> has not been used correctly.  For POST forms, you need to
  ensure:</p>

  <ul>
    <li>The view function uses <a
    href='http://docs.djangoproject.com/en/dev/ref/templates/api/#subclassing-context-requestcontext'><code>RequestContext</code></a>
    for the template, instead of <code>Context</code>.</li>

    <li>In the template, there is a <code>{% templatetag openblock %} csrf_token
    {% templatetag closeblock %}</code> template tag inside each POST form that
    targets an internal URL.</li>

    <li>If you are not using <code>CsrfViewMiddleware</code>, then you must use
    <code>csrf_protect</code> on any views that use the <code>csrf_token</code>
    template tag, as well as those that accept the POST data.</li>

  </ul>

  <p>You're seeing the help section of this page because you have <code>DEBUG =
  True</code> in your Django settings file. Change that to <code>False</code>,
  and only the initial error message will be displayed.  </p>

  <p>You can customize this page using the CSRF_FAILURE_VIEW setting.</p>
  {% else %}
  <p><small>More information is available with DEBUG=True.</small></p>

  {% endif %}
</body>
</html>
"""
def csrf_failure(request, reason = "") :
INDENT
    t = Template(CSRF_FAILRE_TEMPLATE)
    c = Context({'DEBUG' : settings.DEBUG,
            'reason' : reason})
    return HttpResponseForbidden(t.render(c), mimetype = 'text/html')
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/decorators/csrf.py.pyindent" startline="1" endline="48">
from django.middleware.csrf import CsrfViewMiddleware
from django.utils.decorators import decorator_from_middleware
try :
INDENT
    from functools import wraps
DEDENT
except ImportError :
INDENT
    from django.utils.functional import wraps
DEDENT
csrf_protect = decorator_from_middleware(CsrfViewMiddleware)
csrf_protect.__name__ = "csrf_protect"
csrf_protect.__doc__ = """
This decorator adds CSRF protection in exactly the same way as
CsrfViewMiddleware, but it can be used on a per view basis.  Using both, or
using the decorator multiple times, is harmless and efficient.
"""
def csrf_response_exempt(view_func) :
INDENT
    def wrapped_view(* args, ** kwargs) :
    INDENT
        resp = view_func(* args, ** kwargs)
        resp.csrf_exempt = True
        return resp
    DEDENT
    return wraps(view_func)(wrapped_view)
DEDENT
def csrf_view_exempt(view_func) :
INDENT
    def wrapped_view(* args, ** kwargs) :
    INDENT
        return view_func(* args, ** kwargs)
    DEDENT
    wrapped_view.csrf_exempt = True
    return wraps(view_func)(wrapped_view)
DEDENT
def csrf_exempt(view_func) :
INDENT
    return csrf_response_exempt(csrf_view_exempt(view_func))
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/decorators/vary.py.pyindent" startline="1" endline="41">
try :
INDENT
    from functools import wraps
DEDENT
except ImportError :
INDENT
    from django.utils.functional import wraps
DEDENT
from django.utils.cache import patch_vary_headers
def vary_on_headers(* headers) :
INDENT
    def decorator(func) :
    INDENT
        def inner_func(* args, ** kwargs) :
        INDENT
            response = func(* args, ** kwargs)
            patch_vary_headers(response, headers)
            return response
        DEDENT
        return wraps(func)(inner_func)
    DEDENT
    return decorator
DEDENT
def vary_on_cookie(func) :
INDENT
    def inner_func(* args, ** kwargs) :
    INDENT
        response = func(* args, ** kwargs)
        patch_vary_headers(response, ('Cookie',))
        return response
    DEDENT
    return wraps(func)(inner_func)
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/decorators/cache.py.pyindent" startline="1" endline="74">
try :
INDENT
    from functools import wraps
DEDENT
except ImportError :
INDENT
    from django.utils.functional import wraps
DEDENT
from django.utils.decorators import decorator_from_middleware_with_args, auto_adapt_to_methods
from django.utils.cache import patch_cache_control, add_never_cache_headers
from django.middleware.cache import CacheMiddleware
def cache_page(* args, ** kwargs) :
INDENT
    key_prefix = kwargs.pop('key_prefix', None)
    assert not kwargs, "The only keyword argument accepted is key_prefix"
    if len(args) > 1 :
    INDENT
        assert len(args) == 2, "cache_page accepts at most 2 arguments"
        if callable(args [0]) :
        INDENT
            return decorator_from_middleware_with_args(CacheMiddleware)(cache_timeout = args [1], key_prefix = key_prefix)(args [0])
        DEDENT
        elif callable(args [1]) :
        INDENT
            return decorator_from_middleware_with_args(CacheMiddleware)(cache_timeout = args [0], key_prefix = key_prefix)(args [1])
        DEDENT
        else :
        INDENT
            assert False, "cache_page must be passed either a single argument (timeout) or a view function and a timeout"
        DEDENT
    DEDENT
    else :
    INDENT
        return decorator_from_middleware_with_args(CacheMiddleware)(cache_timeout = args [0], key_prefix = key_prefix)
    DEDENT
DEDENT
def cache_control(** kwargs) :
INDENT
    def _cache_controller(viewfunc) :
    INDENT
        def _cache_controlled(request, * args, ** kw) :
        INDENT
            response = viewfunc(request, * args, ** kw)
            patch_cache_control(response, ** kwargs)
            return response
        DEDENT
        return wraps(viewfunc)(_cache_controlled)
    DEDENT
    return auto_adapt_to_methods(_cache_controller)
DEDENT
def never_cache(view_func) :
INDENT
    def _wrapped_view_func(request, * args, ** kwargs) :
    INDENT
        response = view_func(request, * args, ** kwargs)
        add_never_cache_headers(response)
        return response
    DEDENT
    return wraps(view_func)(_wrapped_view_func)
DEDENT
never_cache = auto_adapt_to_methods(never_cache)
</source>
<source file="systems/py/Django/trunk/django/views/decorators/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/views/decorators/http.py.pyindent" startline="1" endline="144">
try :
INDENT
    from functools import wraps
DEDENT
except ImportError :
INDENT
    from django.utils.functional import wraps
DEDENT
from calendar import timegm
from datetime import timedelta
from email.Utils import formatdate
from django.utils.decorators import decorator_from_middleware
from django.utils.http import parse_etags, quote_etag
from django.middleware.http import ConditionalGetMiddleware
from django.http import HttpResponseNotAllowed, HttpResponseNotModified, HttpResponse
conditional_page = decorator_from_middleware(ConditionalGetMiddleware)
def require_http_methods(request_method_list) :
INDENT
    def decorator(func) :
    INDENT
        def inner(request, * args, ** kwargs) :
        INDENT
            if request.method not in request_method_list :
            INDENT
                return HttpResponseNotAllowed(request_method_list)
            DEDENT
            return func(request, * args, ** kwargs)
        DEDENT
        return wraps(func)(inner)
    DEDENT
    return decorator
DEDENT
require_GET = require_http_methods(["GET"])
require_GET.__doc__ = "Decorator to require that a view only accept the GET method."
require_POST = require_http_methods(["POST"])
require_POST.__doc__ = "Decorator to require that a view only accept the POST method."
def condition(etag_func = None, last_modified_func = None) :
INDENT
    def decorator(func) :
    INDENT
        def inner(request, * args, ** kwargs) :
        INDENT
            if_modified_since = request.META.get("HTTP_IF_MODIFIED_SINCE")
            if_none_match = request.META.get("HTTP_IF_NONE_MATCH")
            if_match = request.META.get("HTTP_IF_MATCH")
            if if_none_match or if_match :
            INDENT
                try :
                INDENT
                    etags = parse_etags(if_none_match or if_match)
                DEDENT
                except ValueError :
                INDENT
                    if_none_match = None
                    if_match = None

                DEDENT
            DEDENT
            if etag_func :
            INDENT
                res_etag = etag_func(request, * args, ** kwargs)
            DEDENT
            else :
            INDENT
                res_etag = None
            DEDENT
            if last_modified_func :
            INDENT
                dt = last_modified_func(request, * args, ** kwargs)
                if dt :
                INDENT
                    res_last_modified = formatdate(timegm(dt.utctimetuple())) [: 26] + 'GMT'
                DEDENT
                else :
                INDENT
                    res_last_modified = None
                DEDENT
            DEDENT
            else :
            INDENT
                res_last_modified = None
            DEDENT
            response = None
            if not ((if_match and (if_modified_since or if_none_match)) or
                (if_match and if_none_match)) :
            INDENT
                if ((if_none_match and (res_etag in etags or
                            "*" in etags and res_etag)) and
                    (not if_modified_since or
                        res_last_modified == if_modified_since)) :
                INDENT
                    if request.method in ("GET", "HEAD") :
                    INDENT
                        response = HttpResponseNotModified()
                    DEDENT
                    else :
                    INDENT
                        response = HttpResponse(status = 412)
                    DEDENT
                DEDENT
                elif if_match and ((not res_etag and "*" in etags) or
                    (res_etag and res_etag not in etags)) :
                INDENT
                    response = HttpResponse(status = 412)
                DEDENT
                elif (not if_none_match and if_modified_since and
                    request.method == "GET" and
                    res_last_modified == if_modified_since) :
                INDENT
                    response = HttpResponseNotModified()
                DEDENT
            DEDENT
            if response is None :
            INDENT
                response = func(request, * args, ** kwargs)

            DEDENT
            if res_last_modified and not response.has_header('Last-Modified') :
            INDENT
                response ['Last-Modified'] = res_last_modified
            DEDENT
            if res_etag and not response.has_header('ETag') :
            INDENT
                response ['ETag'] = quote_etag(res_etag)
            DEDENT
            return response
        DEDENT
        return inner
    DEDENT
    return decorator

DEDENT
def etag(etag_func) :
INDENT
    return condition(etag_func = etag_func)
DEDENT
def last_modified(last_modified_func) :
INDENT
    return condition(last_modified_func = last_modified_func)
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/views/debug.py.pyindent" startline="1" endline="827">
import os
import re
import sys
import datetime
from django.conf import settings
from django.template import Template, Context, TemplateDoesNotExist
from django.utils.html import escape
from django.utils.importlib import import_module
from django.http import HttpResponse, HttpResponseServerError, HttpResponseNotFound
from django.utils.encoding import smart_unicode, smart_str
HIDDEN_SETTINGS = re.compile('SECRET|PASSWORD|PROFANITIES_LIST')
def linebreak_iter(template_source) :
INDENT
    yield 0
    p = template_source.find('\n')
    while p > = 0 :
    INDENT
        yield p + 1
        p = template_source.find('\n', p + 1)
    DEDENT
    yield len(template_source) + 1
DEDENT
def get_safe_settings() :
INDENT
    "Returns a dictionary of the settings module, with sensitive settings blurred out."
    settings_dict = {}
    for k in dir(settings) :
    INDENT
        if k.isupper() :
        INDENT
            if HIDDEN_SETTINGS.search(k) :
            INDENT
                settings_dict [k] = '********************'
            DEDENT
            else :
            INDENT
                settings_dict [k] = getattr(settings, k)
            DEDENT
        DEDENT
    DEDENT
    return settings_dict
DEDENT
def technical_500_response(request, exc_type, exc_value, tb) :
INDENT
    reporter = ExceptionReporter(request, exc_type, exc_value, tb)
    html = reporter.get_traceback_html()
    return HttpResponseServerError(html, mimetype = 'text/html')
DEDENT
class ExceptionReporter :
INDENT
    def __init__(self, request, exc_type, exc_value, tb) :
    INDENT
        self.request = request
        self.exc_type = exc_type
        self.exc_value = exc_value
        self.tb = tb
        self.template_info = None
        self.template_does_not_exist = False
        self.loader_debug_info = None

        if isinstance(self.exc_type, basestring) :
        INDENT
            self.exc_value = Exception('Deprecated String Exception: %r' % self.exc_type)
            self.exc_type = type(self.exc_value)
        DEDENT
    DEDENT
    def get_traceback_html(self) :
    INDENT
        "Return HTML code for traceback."
        if issubclass(self.exc_type, TemplateDoesNotExist) :
        INDENT
            from django.template.loader import template_source_loaders
            self.template_does_not_exist = True
            self.loader_debug_info = []
            for loader in template_source_loaders :
            INDENT
                try :
                INDENT
                    module = import_module(loader.__module__)
                    source_list_func = module.get_template_sources

                    template_list = [{'name' : t, 'exists' : os.path.exists(t)} for t in source_list_func(str(self.exc_value))]
                DEDENT
                except (ImportError, AttributeError) :
                INDENT
                    template_list = []
                DEDENT
                if hasattr(loader, '__class__') :
                INDENT
                    loader_name = loader.__module__ + '.' + loader.__class__.__name__
                DEDENT
                else :
                INDENT
                    loader_name = loader.__module__ + '.' + loader.__name__
                DEDENT
                self.loader_debug_info.append({
                        'loader' : loader_name,
                        'templates' : template_list,
                        })
            DEDENT
        DEDENT
        if settings.TEMPLATE_DEBUG and hasattr(self.exc_value, 'source') :
        INDENT
            self.get_template_exception_info()
        DEDENT
        frames = self.get_traceback_frames()
        unicode_hint = ''
        if issubclass(self.exc_type, UnicodeError) :
        INDENT
            start = getattr(self.exc_value, 'start', None)
            end = getattr(self.exc_value, 'end', None)
            if start is not None and end is not None :
            INDENT
                unicode_str = self.exc_value.args [1]
                unicode_hint = smart_unicode(unicode_str [max(start - 5, 0) : min(end + 5, len(unicode_str))], 'ascii', errors = 'replace')
            DEDENT
        DEDENT
        from django import get_version
        t = Template(TECHNICAL_500_TEMPLATE, name = 'Technical 500 template')
        c = Context({
                'exception_type' : self.exc_type.__name__,
                'exception_value' : smart_unicode(self.exc_value, errors = 'replace'),
                'unicode_hint' : unicode_hint,
                'frames' : frames,
                'lastframe' : frames [- 1],
                'request' : self.request,
                'settings' : get_safe_settings(),
                'sys_executable' : sys.executable,
                'sys_version_info' : '%d.%d.%d' % sys.version_info [0 : 3],
                'server_time' : datetime.datetime.now(),
                'django_version_info' : get_version(),
                'sys_path' : sys.path,
                'template_info' : self.template_info,
                'template_does_not_exist' : self.template_does_not_exist,
                'loader_debug_info' : self.loader_debug_info,
                })
        return t.render(c)
    DEDENT
    def get_template_exception_info(self) :
    INDENT
        origin, (start, end) = self.exc_value.source
        template_source = origin.reload()
        context_lines = 10
        line = 0
        upto = 0
        source_lines = []
        before = during = after = ""
        for num, next in enumerate(linebreak_iter(template_source)) :
        INDENT
            if start > = upto and end < = next :
            INDENT
                line = num
                before = escape(template_source [upto : start])
                during = escape(template_source [start : end])
                after = escape(template_source [end : next])
            DEDENT
            source_lines.append((num, escape(template_source [upto : next])))
            upto = next
        DEDENT
        total = len(source_lines)
        top = max(1, line - context_lines)
        bottom = min(total, line + 1 + context_lines)
        self.template_info = {
            'message' : self.exc_value.args [0],
            'source_lines' : source_lines [top : bottom],
            'before' : before,
            'during' : during,
            'after' : after,
            'top' : top,
            'bottom' : bottom,
            'total' : total,
            'line' : line,
            'name' : origin.name,
            }
    DEDENT
    def _get_lines_from_file(self, filename, lineno, context_lines, loader = None, module_name = None) :
    INDENT
        source = None
        if loader is not None and hasattr(loader, "get_source") :
        INDENT
            source = loader.get_source(module_name)
            if source is not None :
            INDENT
                source = source.splitlines()
            DEDENT
        DEDENT
        if source is None :
        INDENT
            try :
            INDENT
                f = open(filename)
                try :
                INDENT
                    source = f.readlines()
                DEDENT
                finally :
                INDENT
                    f.close()
                DEDENT
            DEDENT
            except (OSError, IOError) :
            INDENT
                pass
            DEDENT
        DEDENT
        if source is None :
        INDENT
            return None, [], None, []
        DEDENT
        encoding = 'ascii'
        for line in source [: 2] :
        INDENT
            match = re.search(r'coding[:=]\s*([-\w.]+)', line)
            if match :
            INDENT
                encoding = match.group(1)
                break
            DEDENT
        DEDENT
        source = [unicode(sline, encoding, 'replace') for sline in source]
        lower_bound = max(0, lineno - context_lines)
        upper_bound = lineno + context_lines
        pre_context = [line.strip('\n') for line in source [lower_bound : lineno]]
        context_line = source [lineno].strip('\n')
        post_context = [line.strip('\n') for line in source [lineno + 1 : upper_bound]]
        return lower_bound, pre_context, context_line, post_context
    DEDENT
    def get_traceback_frames(self) :
    INDENT
        frames = []
        tb = self.tb
        while tb is not None :
        INDENT
            if tb.tb_frame.f_locals.get('__traceback_hide__') :
            INDENT
                tb = tb.tb_next
                continue
            DEDENT
            filename = tb.tb_frame.f_code.co_filename
            function = tb.tb_frame.f_code.co_name
            lineno = tb.tb_lineno - 1
            loader = tb.tb_frame.f_globals.get('__loader__')
            module_name = tb.tb_frame.f_globals.get('__name__')
            pre_context_lineno, pre_context, context_line, post_context = self._get_lines_from_file(filename, lineno, 7, loader, module_name)
            if pre_context_lineno is not None :
            INDENT
                frames.append({
                        'tb' : tb,
                        'filename' : filename,
                        'function' : function,
                        'lineno' : lineno + 1,
                        'vars' : tb.tb_frame.f_locals.items(),
                        'id' : id(tb),
                        'pre_context' : pre_context,
                        'context_line' : context_line,
                        'post_context' : post_context,
                        'pre_context_lineno' : pre_context_lineno + 1,
                        })
            DEDENT
            tb = tb.tb_next
        DEDENT
        if not frames :
        INDENT
            frames = [{
                    'filename' : '&lt;unknown&gt;',
                    'function' : '?',
                    'lineno' : '?',
                    'context_line' : '???',
                    }]
        DEDENT
        return frames
    DEDENT
    def format_exception(self) :
    INDENT
        import traceback
        frames = self.get_traceback_frames()
        tb = [(f ['filename'], f ['lineno'], f ['function'], f ['context_line']) for f in frames]
        list = ['Traceback (most recent call last):\n']
        list += traceback.format_list(tb)
        list += traceback.format_exception_only(self.exc_type, self.exc_value)
        return list

    DEDENT
DEDENT
def technical_404_response(request, exception) :
INDENT
    "Create a technical 404 error response. The exception should be the Http404."
    try :
    INDENT
        tried = exception.args [0] ['tried']
    DEDENT
    except (IndexError, TypeError) :
    INDENT
        tried = []
    DEDENT
    else :
    INDENT
        if not tried :
        INDENT
            return empty_urlconf(request)
        DEDENT
    DEDENT
    t = Template(TECHNICAL_404_TEMPLATE, name = 'Technical 404 template')
    c = Context({
            'root_urlconf' : settings.ROOT_URLCONF,
            'request_path' : request.path_info [1 :],
            'urlpatterns' : tried,
            'reason' : smart_str(exception, errors = 'replace'),
            'request' : request,
            'settings' : get_safe_settings(),
            })
    return HttpResponseNotFound(t.render(c), mimetype = 'text/html')
DEDENT
def empty_urlconf(request) :
INDENT
    "Create an empty URLconf 404 error response."
    t = Template(EMPTY_URLCONF_TEMPLATE, name = 'Empty URLConf template')
    c = Context({
            'project_name' : settings.SETTINGS_MODULE.split('.') [0]})
    return HttpResponse(t.render(c), mimetype = 'text/html')

DEDENT
TECHNICAL_500_TEMPLATE = """
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="robots" content="NONE,NOARCHIVE">
  <title>{{ exception_type }} at {{ request.path_info|escape }}</title>
  <style type="text/css">
    html * { padding:0; margin:0; }
    body * { padding:10px 20px; }
    body * * { padding:0; }
    body { font:small sans-serif; }
    body>div { border-bottom:1px solid #ddd; }
    h1 { font-weight:normal; }
    h2 { margin-bottom:.8em; }
    h2 span { font-size:80%; color:#666; font-weight:normal; }
    h3 { margin:1em 0 .5em 0; }
    h4 { margin:0 0 .5em 0; font-weight: normal; }
    table { border:1px solid #ccc; border-collapse: collapse; width:100%; background:white; }
    tbody td, tbody th { vertical-align:top; padding:2px 3px; }
    thead th { padding:1px 6px 1px 3px; background:#fefefe; text-align:left; font-weight:normal; font-size:11px; border:1px solid #ddd; }
    tbody th { width:12em; text-align:right; color:#666; padding-right:.5em; }
    table.vars { margin:5px 0 2px 40px; }
    table.vars td, table.req td { font-family:monospace; }
    table td.code { width:100%; }
    table td.code div { overflow:hidden; }
    table.source th { color:#666; }
    table.source td { font-family:monospace; white-space:pre; border-bottom:1px solid #eee; }
    ul.traceback { list-style-type:none; }
    ul.traceback li.frame { margin-bottom:1em; }
    div.context { margin: 10px 0; }
    div.context ol { padding-left:30px; margin:0 10px; list-style-position: inside; }
    div.context ol li { font-family:monospace; white-space:pre; color:#666; cursor:pointer; }
    div.context ol.context-line li { color:black; background-color:#ccc; }
    div.context ol.context-line li span { float: right; }
    div.commands { margin-left: 40px; }
    div.commands a { color:black; text-decoration:none; }
    #summary { background: #ffc; }
    #summary h2 { font-weight: normal; color: #666; }
    #explanation { background:#eee; }
    #template, #template-not-exist { background:#f6f6f6; }
    #template-not-exist ul { margin: 0 0 0 20px; }
    #unicode-hint { background:#eee; }
    #traceback { background:#eee; }
    #requestinfo { background:#f6f6f6; padding-left:120px; }
    #summary table { border:none; background:transparent; }
    #requestinfo h2, #requestinfo h3 { position:relative; margin-left:-100px; }
    #requestinfo h3 { margin-bottom:-1em; }
    .error { background: #ffc; }
    .specific { color:#cc3300; font-weight:bold; }
    h2 span.commands { font-size:.7em;}
    span.commands a:link {color:#5E5694;}
    pre.exception_value { font-family: sans-serif; color: #666; font-size: 1.5em; margin: 10px 0 10px 0; }
  </style>
  <script type="text/javascript">
  //<!--
    function getElementsByClassName(oElm, strTagName, strClassName){
        // Written by Jonathan Snook, http://www.snook.ca/jon; Add-ons by Robert Nyman, http://www.robertnyman.com
        var arrElements = (strTagName == "*" && document.all)? document.all :
        oElm.getElementsByTagName(strTagName);
        var arrReturnElements = new Array();
        strClassName = strClassName.replace(/\-/g, "\\-");
        var oRegExp = new RegExp("(^|\\s)" + strClassName + "(\\s|$)");
        var oElement;
        for(var i=0; i<arrElements.length; i++){
            oElement = arrElements[i];
            if(oRegExp.test(oElement.className)){
                arrReturnElements.push(oElement);
            }
        }
        return (arrReturnElements)
    }
    function hideAll(elems) {
      for (var e = 0; e < elems.length; e++) {
        elems[e].style.display = 'none';
      }
    }
    window.onload = function() {
      hideAll(getElementsByClassName(document, 'table', 'vars'));
      hideAll(getElementsByClassName(document, 'ol', 'pre-context'));
      hideAll(getElementsByClassName(document, 'ol', 'post-context'));
      hideAll(getElementsByClassName(document, 'div', 'pastebin'));
    }
    function toggle() {
      for (var i = 0; i < arguments.length; i++) {
        var e = document.getElementById(arguments[i]);
        if (e) {
          e.style.display = e.style.display == 'none' ? 'block' : 'none';
        }
      }
      return false;
    }
    function varToggle(link, id) {
      toggle('v' + id);
      var s = link.getElementsByTagName('span')[0];
      var uarr = String.fromCharCode(0x25b6);
      var darr = String.fromCharCode(0x25bc);
      s.innerHTML = s.innerHTML == uarr ? darr : uarr;
      return false;
    }
    function switchPastebinFriendly(link) {
      s1 = "Switch to copy-and-paste view";
      s2 = "Switch back to interactive view";
      link.innerHTML = link.innerHTML == s1 ? s2 : s1;
      toggle('browserTraceback', 'pastebinTraceback');
      return false;
    }
    //-->
  </script>
</head>
<body>
<div id="summary">
  <h1>{{ exception_type }} at {{ request.path_info|escape }}</h1>
  <pre class="exception_value">{{ exception_value|escape }}</pre>
  <table class="meta">
    <tr>
      <th>Request Method:</th>
      <td>{{ request.META.REQUEST_METHOD }}</td>
    </tr>
    <tr>
      <th>Request URL:</th>
      <td>{{ request.build_absolute_uri|escape }}</td>
    </tr>
    <tr>
      <th>Exception Type:</th>
      <td>{{ exception_type }}</td>
    </tr>
    <tr>
      <th>Exception Value:</th>
      <td><pre>{{ exception_value|escape }}</pre></td>
    </tr>
    <tr>
      <th>Exception Location:</th>
      <td>{{ lastframe.filename|escape }} in {{ lastframe.function|escape }}, line {{ lastframe.lineno }}</td>
    </tr>
    <tr>
      <th>Python Executable:</th>
      <td>{{ sys_executable|escape }}</td>
    </tr>
    <tr>
      <th>Python Version:</th>
      <td>{{ sys_version_info }}</td>
    </tr>
    <tr>
      <th>Python Path:</th>
      <td>{{ sys_path }}</td>
    </tr>
    <tr>
      <th>Server time:</th>
      <td>{{server_time|date:"r"}}</td>
    </tr>
  </table>
</div>
{% if unicode_hint %}
<div id="unicode-hint">
    <h2>Unicode error hint</h2>
    <p>The string that could not be encoded/decoded was: <strong>{{ unicode_hint|escape }}</strong></p>
</div>
{% endif %}
{% if template_does_not_exist %}
<div id="template-not-exist">
    <h2>Template-loader postmortem</h2>
    {% if loader_debug_info %}
        <p>Django tried loading these templates, in this order:</p>
        <ul>
        {% for loader in loader_debug_info %}
            <li>Using loader <code>{{ loader.loader }}</code>:
                <ul>{% for t in loader.templates %}<li><code>{{ t.name }}</code> (File {% if t.exists %}exists{% else %}does not exist{% endif %})</li>{% endfor %}</ul>
            </li>
        {% endfor %}
        </ul>
    {% else %}
        <p>Django couldn't find any templates because your <code>TEMPLATE_LOADERS</code> setting is empty!</p>
    {% endif %}
</div>
{% endif %}
{% if template_info %}
<div id="template">
   <h2>Template error</h2>
   <p>In template <code>{{ template_info.name }}</code>, error at line <strong>{{ template_info.line }}</strong></p>
   <h3>{{ template_info.message }}</h3>
   <table class="source{% if template_info.top %} cut-top{% endif %}{% ifnotequal template_info.bottom template_info.total %} cut-bottom{% endifnotequal %}">
   {% for source_line in template_info.source_lines %}
   {% ifequal source_line.0 template_info.line %}
       <tr class="error"><th>{{ source_line.0 }}</th>
       <td>{{ template_info.before }}<span class="specific">{{ template_info.during }}</span>{{ template_info.after }}</td></tr>
   {% else %}
      <tr><th>{{ source_line.0 }}</th>
      <td>{{ source_line.1 }}</td></tr>
   {% endifequal %}
   {% endfor %}
   </table>
</div>
{% endif %}
<div id="traceback">
  <h2>Traceback <span class="commands"><a href="#" onclick="return switchPastebinFriendly(this);">Switch to copy-and-paste view</a></span></h2>
  {% autoescape off %}
  <div id="browserTraceback">
    <ul class="traceback">
      {% for frame in frames %}
        <li class="frame">
          <code>{{ frame.filename|escape }}</code> in <code>{{ frame.function|escape }}</code>

          {% if frame.context_line %}
            <div class="context" id="c{{ frame.id }}">
              {% if frame.pre_context %}
                <ol start="{{ frame.pre_context_lineno }}" class="pre-context" id="pre{{ frame.id }}">{% for line in frame.pre_context %}<li onclick="toggle('pre{{ frame.id }}', 'post{{ frame.id }}')">{{ line|escape }}</li>{% endfor %}</ol>
              {% endif %}
              <ol start="{{ frame.lineno }}" class="context-line"><li onclick="toggle('pre{{ frame.id }}', 'post{{ frame.id }}')">{{ frame.context_line|escape }} <span>...</span></li></ol>
              {% if frame.post_context %}
                <ol start='{{ frame.lineno|add:"1" }}' class="post-context" id="post{{ frame.id }}">{% for line in frame.post_context %}<li onclick="toggle('pre{{ frame.id }}', 'post{{ frame.id }}')">{{ line|escape }}</li>{% endfor %}</ol>
              {% endif %}
            </div>
          {% endif %}

          {% if frame.vars %}
            <div class="commands">
                <a href="#" onclick="return varToggle(this, '{{ frame.id }}')"><span>&#x25b6;</span> Local vars</a>
            </div>
            <table class="vars" id="v{{ frame.id }}">
              <thead>
                <tr>
                  <th>Variable</th>
                  <th>Value</th>
                </tr>
              </thead>
              <tbody>
                {% for var in frame.vars|dictsort:"0" %}
                  <tr>
                    <td>{{ var.0|escape }}</td>
                    <td class="code"><div>{{ var.1|pprint|escape }}</div></td>
                  </tr>
                {% endfor %}
              </tbody>
            </table>
          {% endif %}
        </li>
      {% endfor %}
    </ul>
  </div>
  {% endautoescape %}
  <form action="http://dpaste.com/" name="pasteform" id="pasteform" method="post">
  <div id="pastebinTraceback" class="pastebin">
    <input type="hidden" name="language" value="PythonConsole">
    <input type="hidden" name="title" value="{{ exception_type|escape }} at {{ request.path_info|escape }}">
    <input type="hidden" name="source" value="Django Dpaste Agent">
    <input type="hidden" name="poster" value="Django">
    <textarea name="content" id="traceback_area" cols="140" rows="25">
Environment:

Request Method: {{ request.META.REQUEST_METHOD }}
Request URL: {{ request.build_absolute_uri|escape }}
Django Version: {{ django_version_info }}
Python Version: {{ sys_version_info }}
Installed Applications:
{{ settings.INSTALLED_APPS|pprint }}
Installed Middleware:
{{ settings.MIDDLEWARE_CLASSES|pprint }}

{% if template_does_not_exist %}Template Loader Error:
{% if loader_debug_info %}Django tried loading these templates, in this order:
{% for loader in loader_debug_info %}Using loader {{ loader.loader }}:
{% for t in loader.templates %}{{ t.name }} (File {% if t.exists %}exists{% else %}does not exist{% endif %})
{% endfor %}{% endfor %}
{% else %}Django couldn't find any templates because your TEMPLATE_LOADERS setting is empty!
{% endif %}
{% endif %}{% if template_info %}
Template error:
In template {{ template_info.name }}, error at line {{ template_info.line }}
   {{ template_info.message }}{% for source_line in template_info.source_lines %}{% ifequal source_line.0 template_info.line %}
   {{ source_line.0 }} : {{ template_info.before }} {{ template_info.during }} {{ template_info.after }}
{% else %}
   {{ source_line.0 }} : {{ source_line.1 }}
{% endifequal %}{% endfor %}{% endif %}
Traceback:
{% for frame in frames %}File "{{ frame.filename|escape }}" in {{ frame.function|escape }}
{% if frame.context_line %}  {{ frame.lineno }}. {{ frame.context_line|escape }}{% endif %}
{% endfor %}
Exception Type: {{ exception_type|escape }} at {{ request.path_info|escape }}
Exception Value: {{ exception_value|escape }}
</textarea>
  <br><br>
  <input type="submit" value="Share this traceback on a public Web site">
  </div>
</form>
</div>

<div id="requestinfo">
  <h2>Request information</h2>

  <h3 id="get-info">GET</h3>
  {% if request.GET %}
    <table class="req">
      <thead>
        <tr>
          <th>Variable</th>
          <th>Value</th>
        </tr>
      </thead>
      <tbody>
        {% for var in request.GET.items %}
          <tr>
            <td>{{ var.0 }}</td>
            <td class="code"><div>{{ var.1|pprint }}</div></td>
          </tr>
        {% endfor %}
      </tbody>
    </table>
  {% else %}
    <p>No GET data</p>
  {% endif %}

  <h3 id="post-info">POST</h3>
  {% if request.POST %}
    <table class="req">
      <thead>
        <tr>
          <th>Variable</th>
          <th>Value</th>
        </tr>
      </thead>
      <tbody>
        {% for var in request.POST.items %}
          <tr>
            <td>{{ var.0 }}</td>
            <td class="code"><div>{{ var.1|pprint }}</div></td>
          </tr>
        {% endfor %}
      </tbody>
    </table>
  {% else %}
    <p>No POST data</p>
  {% endif %}
  <h3 id="files-info">FILES</h3>
  {% if request.FILES %}
    <table class="req">
        <thead>
            <tr>
                <th>Variable</th>
                <th>Value</th>
            </tr>
        </thead>
        <tbody>
            {% for var in request.FILES.items %}
                <tr>
                    <td>{{ var.0 }}</td>
                    <td class="code"><div>{{ var.1|pprint }}</div></td>
                </tr>
            {% endfor %}
        </tbody>
    </table>
  {% else %}
    <p>No FILES data</p>
  {% endif %}


  <h3 id="cookie-info">COOKIES</h3>
  {% if request.COOKIES %}
    <table class="req">
      <thead>
        <tr>
          <th>Variable</th>
          <th>Value</th>
        </tr>
      </thead>
      <tbody>
        {% for var in request.COOKIES.items %}
          <tr>
            <td>{{ var.0 }}</td>
            <td class="code"><div>{{ var.1|pprint }}</div></td>
          </tr>
        {% endfor %}
      </tbody>
    </table>
  {% else %}
    <p>No cookie data</p>
  {% endif %}

  <h3 id="meta-info">META</h3>
  <table class="req">
    <thead>
      <tr>
        <th>Variable</th>
        <th>Value</th>
      </tr>
    </thead>
    <tbody>
      {% for var in request.META.items|dictsort:"0" %}
        <tr>
          <td>{{ var.0 }}</td>
          <td class="code"><div>{{ var.1|pprint }}</div></td>
        </tr>
      {% endfor %}
    </tbody>
  </table>

  <h3 id="settings-info">Settings</h3>
  <h4>Using settings module <code>{{ settings.SETTINGS_MODULE }}</code></h4>
  <table class="req">
    <thead>
      <tr>
        <th>Setting</th>
        <th>Value</th>
      </tr>
    </thead>
    <tbody>
      {% for var in settings.items|dictsort:"0" %}
        <tr>
          <td>{{ var.0 }}</td>
          <td class="code"><div>{{ var.1|pprint }}</div></td>
        </tr>
      {% endfor %}
    </tbody>
  </table>

</div>

<div id="explanation">
  <p>
    You're seeing this error because you have <code>DEBUG = True</code> in your
    Django settings file. Change that to <code>False</code>, and Django will
    display a standard 500 page.
  </p>
</div>
</body>
</html>
"""
TECHNICAL_404_TEMPLATE = """
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Page not found at {{ request.path_info|escape }}</title>
  <meta name="robots" content="NONE,NOARCHIVE">
  <style type="text/css">
    html * { padding:0; margin:0; }
    body * { padding:10px 20px; }
    body * * { padding:0; }
    body { font:small sans-serif; background:#eee; }
    body>div { border-bottom:1px solid #ddd; }
    h1 { font-weight:normal; margin-bottom:.4em; }
    h1 span { font-size:60%; color:#666; font-weight:normal; }
    table { border:none; border-collapse: collapse; width:100%; }
    td, th { vertical-align:top; padding:2px 3px; }
    th { width:12em; text-align:right; color:#666; padding-right:.5em; }
    #info { background:#f6f6f6; }
    #info ol { margin: 0.5em 4em; }
    #info ol li { font-family: monospace; }
    #summary { background: #ffc; }
    #explanation { background:#eee; border-bottom: 0px none; }
  </style>
</head>
<body>
  <div id="summary">
    <h1>Page not found <span>(404)</span></h1>
    <table class="meta">
      <tr>
        <th>Request Method:</th>
        <td>{{ request.META.REQUEST_METHOD }}</td>
      </tr>
      <tr>
        <th>Request URL:</th>
      <td>{{ request.build_absolute_uri|escape }}</td>
      </tr>
    </table>
  </div>
  <div id="info">
    {% if urlpatterns %}
      <p>
      Using the URLconf defined in <code>{{ settings.ROOT_URLCONF }}</code>,
      Django tried these URL patterns, in this order:
      </p>
      <ol>
        {% for pattern in urlpatterns %}
          <li>{{ pattern }}</li>
        {% endfor %}
      </ol>
      <p>The current URL, <code>{{ request_path|escape }}</code>, didn't match any of these.</p>
    {% else %}
      <p>{{ reason }}</p>
    {% endif %}
  </div>

  <div id="explanation">
    <p>
      You're seeing this error because you have <code>DEBUG = True</code> in
      your Django settings file. Change that to <code>False</code>, and Django
      will display a standard 404 page.
    </p>
  </div>
</body>
</html>
"""
EMPTY_URLCONF_TEMPLATE = """
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="robots" content="NONE,NOARCHIVE"><title>Welcome to Django</title>
  <style type="text/css">
    html * { padding:0; margin:0; }
    body * { padding:10px 20px; }
    body * * { padding:0; }
    body { font:small sans-serif; }
    body>div { border-bottom:1px solid #ddd; }
    h1 { font-weight:normal; }
    h2 { margin-bottom:.8em; }
    h2 span { font-size:80%; color:#666; font-weight:normal; }
    h3 { margin:1em 0 .5em 0; }
    h4 { margin:0 0 .5em 0; font-weight: normal; }
    table { border:1px solid #ccc; border-collapse: collapse; width:100%; background:white; }
    tbody td, tbody th { vertical-align:top; padding:2px 3px; }
    thead th { padding:1px 6px 1px 3px; background:#fefefe; text-align:left; font-weight:normal; font-size:11px; border:1px solid #ddd; }
    tbody th { width:12em; text-align:right; color:#666; padding-right:.5em; }
    ul { margin-left: 2em; margin-top: 1em; }
    #summary { background: #e0ebff; }
    #summary h2 { font-weight: normal; color: #666; }
    #explanation { background:#eee; }
    #instructions { background:#f6f6f6; }
    #summary table { border:none; background:transparent; }
  </style>
</head>

<body>
<div id="summary">
  <h1>It worked!</h1>
  <h2>Congratulations on your first Django-powered page.</h2>
</div>

<div id="instructions">
  <p>Of course, you haven't actually done any work yet. Here's what to do next:</p>
  <ul>
    <li>If you plan to use a database, edit the <code>DATABASES</code> setting in <code>{{ project_name }}/settings.py</code>.</li>
    <li>Start your first app by running <code>python {{ project_name }}/manage.py startapp [appname]</code>.</li>
  </ul>
</div>

<div id="explanation">
  <p>
    You're seeing this message because you have <code>DEBUG = True</code> in your
    Django settings file and you haven't configured any URLs. Get to work!
  </p>
</div>
</body></html>
"""
</source>
<source file="systems/py/Django/trunk/django/views/static.py.pyindent" startline="1" endline="138">
import mimetypes
import os
import posixpath
import re
import stat
import urllib
from email.Utils import parsedate_tz, mktime_tz
from django.template import loader
from django.http import Http404, HttpResponse, HttpResponseRedirect, HttpResponseNotModified
from django.template import Template, Context, TemplateDoesNotExist
from django.utils.http import http_date
def serve(request, path, document_root = None, show_indexes = False) :
INDENT
    path = posixpath.normpath(urllib.unquote(path))
    path = path.lstrip('/')
    newpath = ''
    for part in path.split('/') :
    INDENT
        if not part :
        INDENT
            continue
        DEDENT
        drive, part = os.path.splitdrive(part)
        head, part = os.path.split(part)
        if part in (os.curdir, os.pardir) :
        INDENT
            continue
        DEDENT
        newpath = os.path.join(newpath, part).replace('\\', '/')
    DEDENT
    if newpath and path ! = newpath :
    INDENT
        return HttpResponseRedirect(newpath)
    DEDENT
    fullpath = os.path.join(document_root, newpath)
    if os.path.isdir(fullpath) :
    INDENT
        if show_indexes :
        INDENT
            return directory_index(newpath, fullpath)
        DEDENT
        raise Http404, "Directory indexes are not allowed here."
    DEDENT
    if not os.path.exists(fullpath) :
    INDENT
        raise Http404, '"%s" does not exist' % fullpath
    DEDENT
    statobj = os.stat(fullpath)
    mimetype = mimetypes.guess_type(fullpath) [0] or 'application/octet-stream'
    if not was_modified_since(request.META.get('HTTP_IF_MODIFIED_SINCE'),
        statobj [stat.ST_MTIME], statobj [stat.ST_SIZE]) :
    INDENT
        return HttpResponseNotModified(mimetype = mimetype)
    DEDENT
    contents = open(fullpath, 'rb').read()
    response = HttpResponse(contents, mimetype = mimetype)
    response ["Last-Modified"] = http_date(statobj [stat.ST_MTIME])
    response ["Content-Length"] = len(contents)
    return response
DEDENT
DEFAULT_DIRECTORY_INDEX_TEMPLATE = """
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Language" content="en-us" />
    <meta name="robots" content="NONE,NOARCHIVE" />
    <title>Index of {{ directory }}</title>
  </head>
  <body>
    <h1>Index of {{ directory }}</h1>
    <ul>
      {% ifnotequal directory "/" %}
      <li><a href="../">../</a></li>
      {% endifnotequal %}
      {% for f in file_list %}
      <li><a href="{{ f|urlencode }}">{{ f }}</a></li>
      {% endfor %}
    </ul>
  </body>
</html>
"""
def directory_index(path, fullpath) :
INDENT
    try :
    INDENT
        t = loader.select_template(['static/directory_index.html',
                'static/directory_index'])
    DEDENT
    except TemplateDoesNotExist :
    INDENT
        t = Template(DEFAULT_DIRECTORY_INDEX_TEMPLATE, name = 'Default directory index template')
    DEDENT
    files = []
    for f in os.listdir(fullpath) :
    INDENT
        if not f.startswith('.') :
        INDENT
            if os.path.isdir(os.path.join(fullpath, f)) :
            INDENT
                f += '/'
            DEDENT
            files.append(f)
        DEDENT
    DEDENT
    c = Context({
            'directory' : path + '/',
            'file_list' : files,
            })
    return HttpResponse(t.render(c))
DEDENT
def was_modified_since(header = None, mtime = 0, size = 0) :
INDENT
    try :
    INDENT
        if header is None :
        INDENT
            raise ValueError
        DEDENT
        matches = re.match(r"^([^;]+)(; length=([0-9]+))?$", header,
            re.IGNORECASE)
        header_mtime = mktime_tz(parsedate_tz(matches.group(1)))
        header_len = matches.group(3)
        if header_len and int(header_len) ! = size :
        INDENT
            raise ValueError
        DEDENT
        if mtime > header_mtime :
        INDENT
            raise ValueError
        DEDENT
    DEDENT
    except (AttributeError, ValueError) :
    INDENT
        return True
    DEDENT
    return False
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/defaults.py.pyindent" startline="1" endline="36">
from django import http
from django.template import Context, RequestContext, loader
def page_not_found(request, template_name = '404.html') :
INDENT
    t = loader.get_template(template_name)
    return http.HttpResponseNotFound(t.render(RequestContext(request, {'request_path' : request.path})))
DEDENT
def server_error(request, template_name = '500.html') :
INDENT
    t = loader.get_template(template_name)
    return http.HttpResponseServerError(t.render(Context({})))
DEDENT
def shortcut(request, content_type_id, object_id) :
INDENT
    from django.contrib.contenttypes.views import shortcut as real_shortcut
    return real_shortcut(request, content_type_id, object_id)
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/i18n.py.pyindent" startline="1" endline="249">
import os
import gettext as gettext_module
from django import http
from django.conf import settings
from django.utils import importlib
from django.utils.translation import check_for_language, activate, to_locale, get_language
from django.utils.text import javascript_quote
from django.utils.encoding import smart_unicode
from django.utils.formats import get_format_modules
def set_language(request) :
INDENT
    next = request.REQUEST.get('next', None)
    if not next :
    INDENT
        next = request.META.get('HTTP_REFERER', None)
    DEDENT
    if not next :
    INDENT
        next = '/'
    DEDENT
    response = http.HttpResponseRedirect(next)
    if request.method == 'POST' :
    INDENT
        lang_code = request.POST.get('language', None)
        if lang_code and check_for_language(lang_code) :
        INDENT
            if hasattr(request, 'session') :
            INDENT
                request.session ['django_language'] = lang_code
            DEDENT
            else :
            INDENT
                response.set_cookie(settings.LANGUAGE_COOKIE_NAME, lang_code)
            DEDENT
        DEDENT
    DEDENT
    return response
DEDENT
def get_formats() :
INDENT
    FORMAT_SETTINGS = (
        'DATE_FORMAT', 'DATETIME_FORMAT', 'TIME_FORMAT',
        'YEAR_MONTH_FORMAT', 'MONTH_DAY_FORMAT', 'SHORT_DATE_FORMAT',
        'SHORT_DATETIME_FORMAT', 'FIRST_DAY_OF_WEEK', 'DECIMAL_SEPARATOR',
        'THOUSAND_SEPARATOR', 'NUMBER_GROUPING',
        'DATE_INPUT_FORMATS', 'TIME_INPUT_FORMATS', 'DATETIME_INPUT_FORMATS')
    result = {}
    for module in [settings] + get_format_modules(reverse = True) :
    INDENT
        for attr in FORMAT_SETTINGS :
        INDENT
            try :
            INDENT
                result [attr] = getattr(module, attr)
            DEDENT
            except AttributeError :
            INDENT
                pass
            DEDENT
        DEDENT
    DEDENT
    src = []
    for k, v in result.items() :
    INDENT
        if isinstance(v, (basestring, int)) :
        INDENT
            src.append("formats['%s'] = '%s';\n" % (javascript_quote(k), javascript_quote(smart_unicode(v))))
        DEDENT
        elif isinstance(v, (tuple, list)) :
        INDENT
            v = [javascript_quote(smart_unicode(value)) for value in v]
            src.append("formats['%s'] = ['%s'];\n" % (javascript_quote(k), "', '".join(v)))
        DEDENT
    DEDENT
    return ''.join(src)
DEDENT
NullSource = """
/* gettext identity library */

function gettext(msgid) { return msgid; }
function ngettext(singular, plural, count) { return (count == 1) ? singular : plural; }
function gettext_noop(msgid) { return msgid; }
"""
LibHead = """
/* gettext library */

var catalog = new Array();
"""
LibFoot = """

function gettext(msgid) {
  var value = catalog[msgid];
  if (typeof(value) == 'undefined') {
    return msgid;
  } else {
    return (typeof(value) == 'string') ? value : value[0];
  }
}

function ngettext(singular, plural, count) {
  value = catalog[singular];
  if (typeof(value) == 'undefined') {
    return (count == 1) ? singular : plural;
  } else {
    return value[pluralidx(count)];
  }
}

function gettext_noop(msgid) { return msgid; }

"""
LibFormatHead = """
/* formatting library */

var formats = new Array();

"""
LibFormatFoot = """
function get_format(format_type) {
    var value = formats[format_type];
    if (typeof(value) == 'undefined') {
      return msgid;
    } else {
      return value;
    }
}
"""
SimplePlural = """
function pluralidx(count) { return (count == 1) ? 0 : 1; }
"""
InterPolate = r"""
function interpolate(fmt, obj, named) {
  if (named) {
    return fmt.replace(/%\(\w+\)s/g, function(match){return String(obj[match.slice(2,-2)])});
  } else {
    return fmt.replace(/%s/g, function(match){return String(obj.shift())});
  }
}
"""
PluralIdx = r"""
function pluralidx(n) {
  var v=%s;
  if (typeof(v) == 'boolean') {
    return v ? 1 : 0;
  } else {
    return v;
  }
}
"""
def null_javascript_catalog(request, domain = None, packages = None) :
INDENT
    src = [NullSource, InterPolate, LibFormatHead, get_formats(), LibFormatFoot]
    return http.HttpResponse(''.join(src), 'text/javascript')
DEDENT
def javascript_catalog(request, domain = 'djangojs', packages = None) :
INDENT
    if request.GET :
    INDENT
        if 'language' in request.GET :
        INDENT
            if check_for_language(request.GET ['language']) :
            INDENT
                activate(request.GET ['language'])
            DEDENT
        DEDENT
    DEDENT
    if packages is None :
    INDENT
        packages = ['django.conf']
    DEDENT
    if isinstance(packages, basestring) :
    INDENT
        packages = packages.split('+')
    DEDENT
    packages = [p for p in packages if p == 'django.conf' or p in settings.INSTALLED_APPS]
    default_locale = to_locale(settings.LANGUAGE_CODE)
    locale = to_locale(get_language())
    t = {}
    paths = []
    for package in packages :
    INDENT
        p = importlib.import_module(package)
        path = os.path.join(os.path.dirname(p.__file__), 'locale')
        paths.append(path)
        try :
        INDENT
            catalog = gettext_module.translation(domain, path, ['en'])
            t.update(catalog._catalog)
        DEDENT
        except IOError :
        INDENT
            pass
        DEDENT
    DEDENT
    if default_locale ! = 'en' :
    INDENT
        for path in paths :
        INDENT
            try :
            INDENT
                catalog = gettext_module.translation(domain, path, [default_locale])
            DEDENT
            except IOError :
            INDENT
                catalog = None
            DEDENT
            if catalog is not None :
            INDENT
                t.update(catalog._catalog)
            DEDENT
        DEDENT
    DEDENT
    if locale ! = default_locale :
    INDENT
        for path in paths :
        INDENT
            try :
            INDENT
                catalog = gettext_module.translation(domain, path, [locale])
            DEDENT
            except IOError :
            INDENT
                catalog = None
            DEDENT
            if catalog is not None :
            INDENT
                t.update(catalog._catalog)
            DEDENT
        DEDENT
    DEDENT
    src = [LibHead]
    plural = None
    if '' in t :
    INDENT
        for l in t [''].split('\n') :
        INDENT
            if l.startswith('Plural-Forms:') :
            INDENT
                plural = l.split(':', 1) [1].strip()
            DEDENT
        DEDENT
    DEDENT
    if plural is not None :
    INDENT
        plural = [el.strip() for el in plural.split(';') if el.strip().startswith('plural=')] [0].split('=', 1) [1]
        src.append(PluralIdx % plural)
    DEDENT
    else :
    INDENT
        src.append(SimplePlural)
    DEDENT
    csrc = []
    pdict = {}
    for k, v in t.items() :
    INDENT
        if k == '' :
        INDENT
            continue
        DEDENT
        if isinstance(k, basestring) :
        INDENT
            csrc.append("catalog['%s'] = '%s';\n" % (javascript_quote(k), javascript_quote(v)))
        DEDENT
        elif isinstance(k, tuple) :
        INDENT
            if k [0] not in pdict :
            INDENT
                pdict [k [0]] = k [1]
            DEDENT
            else :
            INDENT
                pdict [k [0]] = max(k [1], pdict [k [0]])
            DEDENT
            csrc.append("catalog['%s'][%d] = '%s';\n" % (javascript_quote(k [0]), k [1], javascript_quote(v)))
        DEDENT
        else :
        INDENT
            raise TypeError, k
        DEDENT
    DEDENT
    csrc.sort()
    for k, v in pdict.items() :
    INDENT
        src.append("catalog['%s'] = [%s];\n" % (javascript_quote(k), ','.join(["''"] * (v + 1))))
    DEDENT
    src.extend(csrc)
    src.append(LibFoot)
    src.append(InterPolate)
    src.append(LibFormatHead)
    src.append(get_formats())
    src.append(LibFormatFoot)
    src = ''.join(src)
    return http.HttpResponse(src, 'text/javascript')
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/generic/list_detail.py.pyindent" startline="1" endline="146">
from django.template import loader, RequestContext
from django.http import Http404, HttpResponse
from django.core.xheaders import populate_xheaders
from django.core.paginator import Paginator, InvalidPage
from django.core.exceptions import ObjectDoesNotExist
def object_list(request, queryset, paginate_by = None, page = None,
allow_empty = True, template_name = None, template_loader = loader,
extra_context = None, context_processors = None, template_object_name = 'object',
mimetype = None) :
INDENT
    if extra_context is None : extra_context = {}
    queryset = queryset._clone()
    if paginate_by :
    INDENT
        paginator = Paginator(queryset, paginate_by, allow_empty_first_page = allow_empty)
        if not page :
        INDENT
            page = request.GET.get('page', 1)
        DEDENT
        try :
        INDENT
            page_number = int(page)
        DEDENT
        except ValueError :
        INDENT
            if page == 'last' :
            INDENT
                page_number = paginator.num_pages
            DEDENT
            else :
            INDENT
                raise Http404
            DEDENT
        DEDENT
        try :
        INDENT
            page_obj = paginator.page(page_number)
        DEDENT
        except InvalidPage :
        INDENT
            raise Http404
        DEDENT
        c = RequestContext(request, {
                '%s_list' % template_object_name : page_obj.object_list,
                'paginator' : paginator,
                'page_obj' : page_obj,
                'is_paginated' : page_obj.has_other_pages(),
                'results_per_page' : paginator.per_page,
                'has_next' : page_obj.has_next(),
                'has_previous' : page_obj.has_previous(),
                'page' : page_obj.number,
                'next' : page_obj.next_page_number(),
                'previous' : page_obj.previous_page_number(),
                'first_on_page' : page_obj.start_index(),
                'last_on_page' : page_obj.end_index(),
                'pages' : paginator.num_pages,
                'hits' : paginator.count,
                'page_range' : paginator.page_range,
                }, context_processors)
    DEDENT
    else :
    INDENT
        c = RequestContext(request, {
                '%s_list' % template_object_name : queryset,
                'paginator' : None,
                'page_obj' : None,
                'is_paginated' : False,
                }, context_processors)
        if not allow_empty and len(queryset) == 0 :
        INDENT
            raise Http404
        DEDENT
    DEDENT
    for key, value in extra_context.items() :
    INDENT
        if callable(value) :
        INDENT
            c [key] = value()
        DEDENT
        else :
        INDENT
            c [key] = value
        DEDENT
    DEDENT
    if not template_name :
    INDENT
        model = queryset.model
        template_name = "%s/%s_list.html" % (model._meta.app_label, model._meta.object_name.lower())
    DEDENT
    t = template_loader.get_template(template_name)
    return HttpResponse(t.render(c), mimetype = mimetype)
DEDENT
def object_detail(request, queryset, object_id = None, slug = None,
slug_field = 'slug', template_name = None, template_name_field = None,
template_loader = loader, extra_context = None,
context_processors = None, template_object_name = 'object',
mimetype = None) :
INDENT
    if extra_context is None : extra_context = {}
    model = queryset.model
    if object_id :
    INDENT
        queryset = queryset.filter(pk = object_id)
    DEDENT
    elif slug and slug_field :
    INDENT
        queryset = queryset.filter(** {slug_field : slug})
    DEDENT
    else :
    INDENT
        raise AttributeError, "Generic detail view must be called with either an object_id or a slug/slug_field."
    DEDENT
    try :
    INDENT
        obj = queryset.get()
    DEDENT
    except ObjectDoesNotExist :
    INDENT
        raise Http404, "No %s found matching the query" % (model._meta.verbose_name)
    DEDENT
    if not template_name :
    INDENT
        template_name = "%s/%s_detail.html" % (model._meta.app_label, model._meta.object_name.lower())
    DEDENT
    if template_name_field :
    INDENT
        template_name_list = [getattr(obj, template_name_field), template_name]
        t = template_loader.select_template(template_name_list)
    DEDENT
    else :
    INDENT
        t = template_loader.get_template(template_name)
    DEDENT
    c = RequestContext(request, {
            template_object_name : obj,
            }, context_processors)
    for key, value in extra_context.items() :
    INDENT
        if callable(value) :
        INDENT
            c [key] = value()
        DEDENT
        else :
        INDENT
            c [key] = value
        DEDENT
    DEDENT
    response = HttpResponse(t.render(c), mimetype = mimetype)
    populate_xheaders(request, response, model, getattr(obj, obj._meta.pk.name))
    return response
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/generic/date_based.py.pyindent" startline="1" endline="365">
import datetime
import time
from django.template import loader, RequestContext
from django.core.exceptions import ObjectDoesNotExist
from django.core.xheaders import populate_xheaders
from django.db.models.fields import DateTimeField
from django.http import Http404, HttpResponse
def archive_index(request, queryset, date_field, num_latest = 15,
template_name = None, template_loader = loader,
extra_context = None, allow_empty = True, context_processors = None,
mimetype = None, allow_future = False, template_object_name = 'latest') :
INDENT
    if extra_context is None : extra_context = {}
    model = queryset.model
    if not allow_future :
    INDENT
        queryset = queryset.filter(** {'%s__lte' % date_field : datetime.datetime.now()})
    DEDENT
    date_list = queryset.dates(date_field, 'year') [: : - 1]
    if not date_list and not allow_empty :
    INDENT
        raise Http404, "No %s available" % model._meta.verbose_name
    DEDENT
    if date_list and num_latest :
    INDENT
        latest = queryset.order_by('-' + date_field) [: num_latest]
    DEDENT
    else :
    INDENT
        latest = None
    DEDENT
    if not template_name :
    INDENT
        template_name = "%s/%s_archive.html" % (model._meta.app_label, model._meta.object_name.lower())
    DEDENT
    t = template_loader.get_template(template_name)
    c = RequestContext(request, {
            'date_list' : date_list,
            template_object_name : latest,
            }, context_processors)
    for key, value in extra_context.items() :
    INDENT
        if callable(value) :
        INDENT
            c [key] = value()
        DEDENT
        else :
        INDENT
            c [key] = value
        DEDENT
    DEDENT
    return HttpResponse(t.render(c), mimetype = mimetype)
DEDENT
def archive_year(request, year, queryset, date_field, template_name = None,
template_loader = loader, extra_context = None, allow_empty = False,
context_processors = None, template_object_name = 'object', mimetype = None,
make_object_list = False, allow_future = False) :
INDENT
    if extra_context is None : extra_context = {}
    model = queryset.model
    now = datetime.datetime.now()
    lookup_kwargs = {'%s__year' % date_field : year}

    if int(year) > = now.year and not allow_future :
    INDENT
        lookup_kwargs ['%s__lte' % date_field] = now
    DEDENT
    date_list = queryset.filter(** lookup_kwargs).dates(date_field, 'month')
    if not date_list and not allow_empty :
    INDENT
        raise Http404
    DEDENT
    if make_object_list :
    INDENT
        object_list = queryset.filter(** lookup_kwargs)
    DEDENT
    else :
    INDENT
        object_list = []
    DEDENT
    if not template_name :
    INDENT
        template_name = "%s/%s_archive_year.html" % (model._meta.app_label, model._meta.object_name.lower())
    DEDENT
    t = template_loader.get_template(template_name)
    c = RequestContext(request, {
            'date_list' : date_list,
            'year' : year,
            '%s_list' % template_object_name : object_list,
            }, context_processors)
    for key, value in extra_context.items() :
    INDENT
        if callable(value) :
        INDENT
            c [key] = value()
        DEDENT
        else :
        INDENT
            c [key] = value
        DEDENT
    DEDENT
    return HttpResponse(t.render(c), mimetype = mimetype)
DEDENT
def archive_month(request, year, month, queryset, date_field,
month_format = '%b', template_name = None, template_loader = loader,
extra_context = None, allow_empty = False, context_processors = None,
template_object_name = 'object', mimetype = None, allow_future = False) :
INDENT
    if extra_context is None : extra_context = {}
    try :
    INDENT
        tt = time.strptime("%s-%s" % (year, month), '%s-%s' % ('%Y', month_format))
        date = datetime.date(* tt [: 3])
    DEDENT
    except ValueError :
    INDENT
        raise Http404
    DEDENT
    model = queryset.model
    now = datetime.datetime.now()

    first_day = date.replace(day = 1)
    if first_day.month == 12 :
    INDENT
        last_day = first_day.replace(year = first_day.year + 1, month = 1)
    DEDENT
    else :
    INDENT
        last_day = first_day.replace(month = first_day.month + 1)
    DEDENT
    lookup_kwargs = {
        '%s__gte' % date_field : first_day,
        '%s__lt' % date_field : last_day,
        }

    if last_day > = now.date() and not allow_future :
    INDENT
        lookup_kwargs ['%s__lte' % date_field] = now
    DEDENT
    object_list = queryset.filter(** lookup_kwargs)
    if not object_list and not allow_empty :
    INDENT
        raise Http404
    DEDENT
    if allow_future :
    INDENT
        next_month = last_day
    DEDENT
    elif last_day < = datetime.date.today() :
    INDENT
        next_month = last_day
    DEDENT
    else :
    INDENT
        next_month = None

    DEDENT
    if first_day.month == 1 :
    INDENT
        previous_month = first_day.replace(year = first_day.year - 1, month = 12)
    DEDENT
    else :
    INDENT
        previous_month = first_day.replace(month = first_day.month - 1)
    DEDENT
    if not template_name :
    INDENT
        template_name = "%s/%s_archive_month.html" % (model._meta.app_label, model._meta.object_name.lower())
    DEDENT
    t = template_loader.get_template(template_name)
    c = RequestContext(request, {
            '%s_list' % template_object_name : object_list,
            'month' : date,
            'next_month' : next_month,
            'previous_month' : previous_month,
            }, context_processors)
    for key, value in extra_context.items() :
    INDENT
        if callable(value) :
        INDENT
            c [key] = value()
        DEDENT
        else :
        INDENT
            c [key] = value
        DEDENT
    DEDENT
    return HttpResponse(t.render(c), mimetype = mimetype)
DEDENT
def archive_week(request, year, week, queryset, date_field,
template_name = None, template_loader = loader,
extra_context = None, allow_empty = True, context_processors = None,
template_object_name = 'object', mimetype = None, allow_future = False) :
INDENT
    if extra_context is None : extra_context = {}
    try :
    INDENT
        tt = time.strptime(year + '-0-' + week, '%Y-%w-%U')
        date = datetime.date(* tt [: 3])
    DEDENT
    except ValueError :
    INDENT
        raise Http404
    DEDENT
    model = queryset.model
    now = datetime.datetime.now()

    first_day = date
    last_day = date + datetime.timedelta(days = 7)
    lookup_kwargs = {
        '%s__gte' % date_field : first_day,
        '%s__lt' % date_field : last_day,
        }

    if last_day > = now.date() and not allow_future :
    INDENT
        lookup_kwargs ['%s__lte' % date_field] = now
    DEDENT
    object_list = queryset.filter(** lookup_kwargs)
    if not object_list and not allow_empty :
    INDENT
        raise Http404
    DEDENT
    if not template_name :
    INDENT
        template_name = "%s/%s_archive_week.html" % (model._meta.app_label, model._meta.object_name.lower())
    DEDENT
    t = template_loader.get_template(template_name)
    c = RequestContext(request, {
            '%s_list' % template_object_name : object_list,
            'week' : date,
            })
    for key, value in extra_context.items() :
    INDENT
        if callable(value) :
        INDENT
            c [key] = value()
        DEDENT
        else :
        INDENT
            c [key] = value
        DEDENT
    DEDENT
    return HttpResponse(t.render(c), mimetype = mimetype)
DEDENT
def archive_day(request, year, month, day, queryset, date_field,
month_format = '%b', day_format = '%d', template_name = None,
template_loader = loader, extra_context = None, allow_empty = False,
context_processors = None, template_object_name = 'object',
mimetype = None, allow_future = False) :
INDENT
    if extra_context is None : extra_context = {}
    try :
    INDENT
        tt = time.strptime('%s-%s-%s' % (year, month, day),
            '%s-%s-%s' % ('%Y', month_format, day_format))
        date = datetime.date(* tt [: 3])
    DEDENT
    except ValueError :
    INDENT
        raise Http404
    DEDENT
    model = queryset.model
    now = datetime.datetime.now()
    if isinstance(model._meta.get_field(date_field), DateTimeField) :
    INDENT
        lookup_kwargs = {'%s__range' % date_field : (datetime.datetime.combine(date, datetime.time.min), datetime.datetime.combine(date, datetime.time.max))}
    DEDENT
    else :
    INDENT
        lookup_kwargs = {date_field : date}

    DEDENT
    if date > = now.date() and not allow_future :
    INDENT
        lookup_kwargs ['%s__lte' % date_field] = now
    DEDENT
    object_list = queryset.filter(** lookup_kwargs)
    if not allow_empty and not object_list :
    INDENT
        raise Http404
    DEDENT
    if allow_future :
    INDENT
        next_day = date + datetime.timedelta(days = 1)
    DEDENT
    elif date < datetime.date.today() :
    INDENT
        next_day = date + datetime.timedelta(days = 1)
    DEDENT
    else :
    INDENT
        next_day = None
    DEDENT
    if not template_name :
    INDENT
        template_name = "%s/%s_archive_day.html" % (model._meta.app_label, model._meta.object_name.lower())
    DEDENT
    t = template_loader.get_template(template_name)
    c = RequestContext(request, {
            '%s_list' % template_object_name : object_list,
            'day' : date,
            'previous_day' : date - datetime.timedelta(days = 1),
            'next_day' : next_day,
            }, context_processors)
    for key, value in extra_context.items() :
    INDENT
        if callable(value) :
        INDENT
            c [key] = value()
        DEDENT
        else :
        INDENT
            c [key] = value
        DEDENT
    DEDENT
    return HttpResponse(t.render(c), mimetype = mimetype)
DEDENT
def archive_today(request, ** kwargs) :
INDENT
    today = datetime.date.today()
    kwargs.update({
            'year' : str(today.year),
            'month' : today.strftime('%b').lower(),
            'day' : str(today.day),
            })
    return archive_day(request, ** kwargs)
DEDENT
def object_detail(request, year, month, day, queryset, date_field,
month_format = '%b', day_format = '%d', object_id = None, slug = None,
slug_field = 'slug', template_name = None, template_name_field = None,
template_loader = loader, extra_context = None, context_processors = None,
template_object_name = 'object', mimetype = None, allow_future = False) :
INDENT
    if extra_context is None : extra_context = {}
    try :
    INDENT
        tt = time.strptime('%s-%s-%s' % (year, month, day),
            '%s-%s-%s' % ('%Y', month_format, day_format))
        date = datetime.date(* tt [: 3])
    DEDENT
    except ValueError :
    INDENT
        raise Http404
    DEDENT
    model = queryset.model
    now = datetime.datetime.now()
    if isinstance(model._meta.get_field(date_field), DateTimeField) :
    INDENT
        lookup_kwargs = {'%s__range' % date_field : (datetime.datetime.combine(date, datetime.time.min), datetime.datetime.combine(date, datetime.time.max))}
    DEDENT
    else :
    INDENT
        lookup_kwargs = {date_field : date}

    DEDENT
    if date > = now.date() and not allow_future :
    INDENT
        lookup_kwargs ['%s__lte' % date_field] = now
    DEDENT
    if object_id :
    INDENT
        lookup_kwargs ['%s__exact' % model._meta.pk.name] = object_id
    DEDENT
    elif slug and slug_field :
    INDENT
        lookup_kwargs ['%s__exact' % slug_field] = slug
    DEDENT
    else :
    INDENT
        raise AttributeError, "Generic detail view must be called with either an object_id or a slug/slugfield"
    DEDENT
    try :
    INDENT
        obj = queryset.get(** lookup_kwargs)
    DEDENT
    except ObjectDoesNotExist :
    INDENT
        raise Http404, "No %s found for" % model._meta.verbose_name
    DEDENT
    if not template_name :
    INDENT
        template_name = "%s/%s_detail.html" % (model._meta.app_label, model._meta.object_name.lower())
    DEDENT
    if template_name_field :
    INDENT
        template_name_list = [getattr(obj, template_name_field), template_name]
        t = template_loader.select_template(template_name_list)
    DEDENT
    else :
    INDENT
        t = template_loader.get_template(template_name)
    DEDENT
    c = RequestContext(request, {
            template_object_name : obj,
            }, context_processors)
    for key, value in extra_context.items() :
    INDENT
        if callable(value) :
        INDENT
            c [key] = value()
        DEDENT
        else :
        INDENT
            c [key] = value
        DEDENT
    DEDENT
    response = HttpResponse(t.render(c), mimetype = mimetype)
    populate_xheaders(request, response, model, getattr(obj, obj._meta.pk.name))
    return response
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/generic/__init__.py.pyindent" startline="1" endline="4">
class GenericViewError(Exception) :
INDENT
    pass
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/generic/create_update.py.pyindent" startline="1" endline="213">
from django.forms.models import ModelFormMetaclass, ModelForm
from django.template import RequestContext, loader
from django.http import Http404, HttpResponse, HttpResponseRedirect
from django.core.xheaders import populate_xheaders
from django.core.exceptions import ObjectDoesNotExist, ImproperlyConfigured
from django.utils.translation import ugettext
from django.contrib.auth.views import redirect_to_login
from django.views.generic import GenericViewError
from django.contrib import messages
def apply_extra_context(extra_context, context) :
INDENT
    for key, value in extra_context.iteritems() :
    INDENT
        if callable(value) :
        INDENT
            context [key] = value()
        DEDENT
        else :
        INDENT
            context [key] = value
        DEDENT
    DEDENT
DEDENT
def get_model_and_form_class(model, form_class) :
INDENT
    if form_class :
    INDENT
        return form_class._meta.model, form_class
    DEDENT
    if model :
    INDENT
        tmp_model = model

        class Meta :
        INDENT
            model = tmp_model
        DEDENT
        class_name = model.__name__ + 'Form'
        form_class = ModelFormMetaclass(class_name, (ModelForm,), {'Meta' : Meta})
        return model, form_class
    DEDENT
    raise GenericViewError("Generic view must be called with either a model or"
        " form_class argument.")
DEDENT
def redirect(post_save_redirect, obj) :
INDENT
    if post_save_redirect :
    INDENT
        return HttpResponseRedirect(post_save_redirect % obj.__dict__)
    DEDENT
    elif hasattr(obj, 'get_absolute_url') :
    INDENT
        return HttpResponseRedirect(obj.get_absolute_url())
    DEDENT
    else :
    INDENT
        raise ImproperlyConfigured(
            "No URL to redirect to.  Either pass a post_save_redirect"
            " parameter to the generic view or define a get_absolute_url"
            " method on the Model.")
    DEDENT
DEDENT
def lookup_object(model, object_id, slug, slug_field) :
INDENT
    lookup_kwargs = {}
    if object_id :
    INDENT
        lookup_kwargs ['%s__exact' % model._meta.pk.name] = object_id
    DEDENT
    elif slug and slug_field :
    INDENT
        lookup_kwargs ['%s__exact' % slug_field] = slug
    DEDENT
    else :
    INDENT
        raise GenericViewError(
            "Generic view must be called with either an object_id or a"
            " slug/slug_field.")
    DEDENT
    try :
    INDENT
        return model.objects.get(** lookup_kwargs)
    DEDENT
    except ObjectDoesNotExist :
    INDENT
        raise Http404("No %s found for %s"
            % (model._meta.verbose_name, lookup_kwargs))
    DEDENT
DEDENT
def create_object(request, model = None, template_name = None,
template_loader = loader, extra_context = None, post_save_redirect = None,
login_required = False, context_processors = None, form_class = None) :
INDENT
    if extra_context is None : extra_context = {}
    if login_required and not request.user.is_authenticated() :
    INDENT
        return redirect_to_login(request.path)
    DEDENT
    model, form_class = get_model_and_form_class(model, form_class)
    if request.method == 'POST' :
    INDENT
        form = form_class(request.POST, request.FILES)
        if form.is_valid() :
        INDENT
            new_object = form.save()
            msg = ugettext("The %(verbose_name)s was created successfully.") % {"verbose_name" : model._meta.verbose_name}
            messages.success(request, msg, fail_silently = True)
            return redirect(post_save_redirect, new_object)
        DEDENT
    DEDENT
    else :
    INDENT
        form = form_class()

    DEDENT
    if not template_name :
    INDENT
        template_name = "%s/%s_form.html" % (model._meta.app_label, model._meta.object_name.lower())
    DEDENT
    t = template_loader.get_template(template_name)
    c = RequestContext(request, {
            'form' : form,
            }, context_processors)
    apply_extra_context(extra_context, c)
    return HttpResponse(t.render(c))
DEDENT
def update_object(request, model = None, object_id = None, slug = None,
slug_field = 'slug', template_name = None, template_loader = loader,
extra_context = None, post_save_redirect = None, login_required = False,
context_processors = None, template_object_name = 'object',
form_class = None) :
INDENT
    if extra_context is None : extra_context = {}
    if login_required and not request.user.is_authenticated() :
    INDENT
        return redirect_to_login(request.path)
    DEDENT
    model, form_class = get_model_and_form_class(model, form_class)
    obj = lookup_object(model, object_id, slug, slug_field)
    if request.method == 'POST' :
    INDENT
        form = form_class(request.POST, request.FILES, instance = obj)
        if form.is_valid() :
        INDENT
            obj = form.save()
            msg = ugettext("The %(verbose_name)s was updated successfully.") % {"verbose_name" : model._meta.verbose_name}
            messages.success(request, msg, fail_silently = True)
            return redirect(post_save_redirect, obj)
        DEDENT
    DEDENT
    else :
    INDENT
        form = form_class(instance = obj)
    DEDENT
    if not template_name :
    INDENT
        template_name = "%s/%s_form.html" % (model._meta.app_label, model._meta.object_name.lower())
    DEDENT
    t = template_loader.get_template(template_name)
    c = RequestContext(request, {
            'form' : form,
            template_object_name : obj,
            }, context_processors)
    apply_extra_context(extra_context, c)
    response = HttpResponse(t.render(c))
    populate_xheaders(request, response, model, getattr(obj, obj._meta.pk.attname))
    return response
DEDENT
def delete_object(request, model, post_delete_redirect, object_id = None,
slug = None, slug_field = 'slug', template_name = None,
template_loader = loader, extra_context = None, login_required = False,
context_processors = None, template_object_name = 'object') :
INDENT
    if extra_context is None : extra_context = {}
    if login_required and not request.user.is_authenticated() :
    INDENT
        return redirect_to_login(request.path)
    DEDENT
    obj = lookup_object(model, object_id, slug, slug_field)
    if request.method == 'POST' :
    INDENT
        obj.delete()
        msg = ugettext("The %(verbose_name)s was deleted.") % {"verbose_name" : model._meta.verbose_name}
        messages.success(request, msg, fail_silently = True)
        return HttpResponseRedirect(post_delete_redirect)
    DEDENT
    else :
    INDENT
        if not template_name :
        INDENT
            template_name = "%s/%s_confirm_delete.html" % (model._meta.app_label, model._meta.object_name.lower())
        DEDENT
        t = template_loader.get_template(template_name)
        c = RequestContext(request, {
                template_object_name : obj,
                }, context_processors)
        apply_extra_context(extra_context, c)
        response = HttpResponse(t.render(c))
        populate_xheaders(request, response, model, getattr(obj, obj._meta.pk.attname))
        return response
    DEDENT
DEDENT
</source>
<source file="systems/py/Django/trunk/django/views/generic/simple.py.pyindent" startline="1" endline="42">
from django.template import loader, RequestContext
from django.http import HttpResponse, HttpResponseRedirect, HttpResponsePermanentRedirect, HttpResponseGone
def direct_to_template(request, template, extra_context = None, mimetype = None, ** kwargs) :
INDENT
    if extra_context is None : extra_context = {}
    dictionary = {'params' : kwargs}
    for key, value in extra_context.items() :
    INDENT
        if callable(value) :
        INDENT
            dictionary [key] = value()
        DEDENT
        else :
        INDENT
            dictionary [key] = value
        DEDENT
    DEDENT
    c = RequestContext(request, dictionary)
    t = loader.get_template(template)
    return HttpResponse(t.render(c), mimetype = mimetype)
DEDENT
def redirect_to(request, url, permanent = True, ** kwargs) :
INDENT
    if url is not None :
    INDENT
        klass = permanent and HttpResponsePermanentRedirect or HttpResponseRedirect
        return klass(url % kwargs)
    DEDENT
    else :
    INDENT
        return HttpResponseGone()
    DEDENT
DEDENT
</source>
<source file="systems/py/Django/trunk/django/conf/locale/sl/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/sl/formats.py.pyindent" startline="1" endline="18">
DATE_FORMAT = 'd. F Y'
TIME_FORMAT = 'H:i:s'

MONTH_DAY_FORMAT = 'j. F'
SHORT_DATE_FORMAT = 'j. M. Y'

DECIMAL_SEPARATOR = ','
THOUSAND_SEPARATOR = '.'
</source>
<source file="systems/py/Django/trunk/django/conf/locale/sk/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/sk/formats.py.pyindent" startline="1" endline="18">
DATE_FORMAT = 'j. F Y'
TIME_FORMAT = 'G:i:s'
YEAR_MONTH_FORMAT = 'F Y'
MONTH_DAY_FORMAT = 'j. F'
SHORT_DATE_FORMAT = 'j.n.Y'

DECIMAL_SEPARATOR = ','
THOUSAND_SEPARATOR = ''
</source>
<source file="systems/py/Django/trunk/django/conf/locale/pl/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/pl/formats.py.pyindent" startline="1" endline="18">
DATE_FORMAT = 'j F Y'
TIME_FORMAT = 'H:i:s'
YEAR_MONTH_FORMAT = 'F Y'
MONTH_DAY_FORMAT = 'j F'
SHORT_DATE_FORMAT = 'd-m-Y'

DECIMAL_SEPARATOR = ','
THOUSAND_SEPARATOR = ''
</source>
<source file="systems/py/Django/trunk/django/conf/locale/sv/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/sv/formats.py.pyindent" startline="1" endline="18">
DATE_FORMAT = 'j F Y'
TIME_FORMAT = 'H.i.s'
YEAR_MONTH_FORMAT = 'Y F'
MONTH_DAY_FORMAT = 'j F'
SHORT_DATE_FORMAT = 'j M Y'

DECIMAL_SEPARATOR = ','
THOUSAND_SEPARATOR = ''
</source>
<source file="systems/py/Django/trunk/django/conf/locale/ga/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/ga/formats.py.pyindent" startline="1" endline="18">
DATE_FORMAT = 'j F Y'
TIME_FORMAT = 'H:i:s'

MONTH_DAY_FORMAT = 'j F'
SHORT_DATE_FORMAT = 'j M Y'

DECIMAL_SEPARATOR = '.'
THOUSAND_SEPARATOR = ','
</source>
<source file="systems/py/Django/trunk/django/conf/locale/he/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/he/formats.py.pyindent" startline="1" endline="18">
DATE_FORMAT = 'j F Y'
TIME_FORMAT = 'H:i:s'
DATETIME_FORMAT = 'j F Y H:i:s'
YEAR_MONTH_FORMAT = 'F Y'
MONTH_DAY_FORMAT = 'j F'
SHORT_DATE_FORMAT = 'd/m/Y'
SHORT_DATETIME_FORMAT = 'd/m/Y H:i:s'

DECIMAL_SEPARATOR = '.'
THOUSAND_SEPARATOR = ','
</source>
<source file="systems/py/Django/trunk/django/conf/locale/km/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/km/formats.py.pyindent" startline="1" endline="18">
DATE_FORMAT = 'j  F  Y'
TIME_FORMAT = 'G:i:s'
DATETIME_FORMAT = 'j  F  Y, G:i:s'
MONTH_DAY_FORMAT = 'j F'
SHORT_DATE_FORMAT = 'j M Y'
SHORT_DATETIME_FORMAT = 'j M Y, G:i:s'

DECIMAL_SEPARATOR = ','
THOUSAND_SEPARATOR = '.'
</source>
<source file="systems/py/Django/trunk/django/conf/locale/da/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/da/formats.py.pyindent" startline="1" endline="26">
DATE_FORMAT = 'j. F Y'
TIME_FORMAT = 'H:i'
DATETIME_FORMAT = 'j. F Y H:i'
YEAR_MONTH_FORMAT = 'F Y'
MONTH_DAY_FORMAT = 'j. F'
SHORT_DATE_FORMAT = 'd.m.Y'
SHORT_DATETIME_FORMAT = 'd.m.Y H:i'
FIRST_DAY_OF_WEEK = 1
DATE_INPUT_FORMATS = (
    '%d.%m.%Y',
    )
TIME_INPUT_FORMATS = (
    '%H:%M:%S',
    '%H:%M',
    )
DATETIME_INPUT_FORMATS = (
    '%d.%m.%Y %H:%M:%S',
    '%d.%m.%Y %H:%M',
    )
DECIMAL_SEPARATOR = ','
THOUSAND_SEPARATOR = '.'
NUMBER_GROUPING = 3
</source>
<source file="systems/py/Django/trunk/django/conf/locale/no/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/no/formats.py.pyindent" startline="1" endline="34">
DATE_FORMAT = 'j. F Y'
TIME_FORMAT = 'H:i'
DATETIME_FORMAT = 'j. F Y H:i'
YEAR_MONTH_FORMAT = 'F Y'
MONTH_DAY_FORMAT = 'j. F'
SHORT_DATE_FORMAT = 'd.m.Y'
SHORT_DATETIME_FORMAT = 'd.m.Y H:i'
FIRST_DAY_OF_WEEK = 1
DATE_INPUT_FORMATS = (
    '%Y-%m-%d', '%j.%m.%Y', '%j.%m.%y',
    '%Y-%m-%j',
    '%j. %b %Y', '%j %b %Y',
    '%j. %b. %Y', '%j %b. %Y',
    '%j. %B %Y', '%j %B %Y',
    )
TIME_INPUT_FORMATS = (
    '%H:%M:%S',
    '%H:%M',
    )
DATETIME_INPUT_FORMATS = (
    '%Y-%m-%d %H:%M:%S',
    '%Y-%m-%d %H:%M',
    '%Y-%m-%d',
    '%Y-%m-%j',
    '%j.%m.%Y %H:%M:%S',
    '%j.%m.%Y %H:%M',
    '%j.%m.%Y',
    '%j.%m.%y %H:%M:%S',
    '%j.%m.%y %H:%M',
    '%j.%m.%y',
    )
DECIMAL_SEPARATOR = ','
THOUSAND_SEPARATOR = ' '
NUMBER_GROUPING = 3
</source>
<source file="systems/py/Django/trunk/django/conf/locale/pt_BR/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/pt_BR/formats.py.pyindent" startline="1" endline="35">
DATE_FORMAT = 'j \\de N \\de Y'
TIME_FORMAT = 'H:i'
DATETIME_FORMAT = 'j \\de N \\de Y \\s H:i'
YEAR_MONTH_FORMAT = 'F \\de Y'
MONTH_DAY_FORMAT = 'j \\de F'
SHORT_DATE_FORMAT = 'd/m/Y'
SHORT_DATETIME_FORMAT = 'd/m/Y H:i'
FIRST_DAY_OF_WEEK = 0
DATE_INPUT_FORMATS = (
    '%Y-%m-%d', '%d/%m/%Y', '%d/%m/%y',
    '%d de %b de %Y', '%d de %b, %Y',
    '%d de %B de %Y', '%d de %B, %Y',
    )
TIME_INPUT_FORMATS = (
    '%H:%M:%S',
    '%H:%M',
    )
DATETIME_INPUT_FORMATS = (
    '%Y-%m-%d %H:%M:%S',
    '%Y-%m-%d %H:%M',
    '%Y-%m-%d',
    '%d/%m/%Y %H:%M:%S',
    '%d/%m/%Y %H:%M',
    '%d/%m/%Y',
    '%d/%m/%y %H:%M:%S',
    '%d/%m/%y %H:%M',
    '%d/%m/%y',
    )
DECIMAL_SEPARATOR = ','
THOUSAND_SEPARATOR = '.'
NUMBER_GROUPING = 3
</source>
<source file="systems/py/Django/trunk/django/conf/locale/ja/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/ja/formats.py.pyindent" startline="1" endline="18">
DATE_FORMAT = 'Ynj'
TIME_FORMAT = 'G:i:s'
DATETIME_FORMAT = 'YnjG:i:s'
YEAR_MONTH_FORMAT = 'Yn'
MONTH_DAY_FORMAT = 'nj'
SHORT_DATE_FORMAT = 'Y/m/d'
SHORT_DATETIME_FORMAT = 'Y/m/d G:i:s'

DECIMAL_SEPARATOR = '.'
THOUSAND_SEPARATOR = ','
</source>
<source file="systems/py/Django/trunk/django/conf/locale/el/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/el/formats.py.pyindent" startline="1" endline="18">
DATE_FORMAT = 'd F Y'
TIME_FORMAT = 'g:i:s A'
YEAR_MONTH_FORMAT = 'F Y'
MONTH_DAY_FORMAT = 'j F'
SHORT_DATE_FORMAT = 'd M Y'

DECIMAL_SEPARATOR = ','
THOUSAND_SEPARATOR = '.'
</source>
<source file="systems/py/Django/trunk/django/conf/locale/lv/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/lv/formats.py.pyindent" startline="1" endline="18">
DATE_FORMAT = 'Y. \g\a\d\a j. F'
TIME_FORMAT = 'H:i:s'
YEAR_MONTH_FORMAT = 'Y. \g. F'
MONTH_DAY_FORMAT = 'j. F'
SHORT_DATE_FORMAT = 'Y. \g\a\d\a j. M'

DECIMAL_SEPARATOR = ','
THOUSAND_SEPARATOR = ''
</source>
<source file="systems/py/Django/trunk/django/conf/locale/it/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/it/formats.py.pyindent" startline="1" endline="41">
DATE_FORMAT = 'd F Y'
TIME_FORMAT = 'H:i:s'
DATETIME_FORMAT = 'w d F Y H:i:s'
YEAR_MONTH_FORMAT = 'F Y'
MONTH_DAY_FORMAT = 'j/F'
SHORT_DATE_FORMAT = 'd/M/Y'
SHORT_DATETIME_FORMAT = 'd/M/Y H:i:s'
FIRST_DAY_OF_WEEK = 1
DATE_INPUT_FORMATS = (
    '%Y-%m-%d', '%Y/%m/%d',
    '%d-%m-%Y', '%d/%m/%Y',
    '%d-%m-%y', '%d/%m/%y',
    )
TIME_INPUT_FORMATS = (
    '%H:%M:%S',
    '%H:%M',
    )
DATETIME_INPUT_FORMATS = (
    '%Y-%m-%d %H:%M:%S',
    '%Y-%m-%d %H:%M',
    '%Y-%m-%d',
    '%d-%m-%Y %H:%M:%S',
    '%d-%m-%Y %H:%M',
    '%d-%m-%Y',
    '%d-%m-%y %H:%M:%S',
    '%d-%m-%y %H:%M',
    '%d-%m-%y',
    '%d/%m/%Y %H:%M:%S',
    '%d/%m/%Y %H:%M',
    '%d/%m/%Y',
    '%d/%m/%y %H:%M:%S',
    '%d/%m/%y %H:%M',
    '%d/%m/%y',
    )
DECIMAL_SEPARATOR = ','
THOUSAND_SEPARATOR = '.'
NUMBER_GROUPING = 3
</source>
<source file="systems/py/Django/trunk/django/conf/locale/ca/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/ca/formats.py.pyindent" startline="1" endline="30">
DATE_FORMAT = 'j \de F \de Y'
TIME_FORMAT = 'G:i:s'
DATETIME_FORMAT = 'j \de F \de Y \\a \le\s G:i'
YEAR_MONTH_FORMAT = 'F \de\l Y'
MONTH_DAY_FORMAT = 'j \de F'
SHORT_DATE_FORMAT = 'd/m/Y'
SHORT_DATETIME_FORMAT = 'd/m/Y G:i'
FIRST_DAY_OF_WEEK = 1
DATE_INPUT_FORMATS = (
    '%d/%m/%Y', '%d/%m/%y')
TIME_INPUT_FORMATS = (
    '%H:%M:%S', '%H:%M')
DATETIME_INPUT_FORMATS = (
    '%d/%m/%Y %H:%M:%S',
    '%d/%m/%Y %H:%M',
    '%d/%m/%y %H:%M:%S',
    '%d/%m/%y %H:%M',
    )
DECIMAL_SEPARATOR = ','
THOUSAND_SEPARATOR = '.'
NUMBER_GROUPING = 3
</source>
<source file="systems/py/Django/trunk/django/conf/locale/zh_TW/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/zh_TW/formats.py.pyindent" startline="1" endline="18">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/is/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/is/formats.py.pyindent" startline="1" endline="18">
DATE_FORMAT = 'j. F Y'
TIME_FORMAT = 'H:i:s'
YEAR_MONTH_FORMAT = 'F Y'
MONTH_DAY_FORMAT = 'j. F'
SHORT_DATE_FORMAT = 'j.n.Y'

DECIMAL_SEPARATOR = ','
THOUSAND_SEPARATOR = '.'
</source>
<source file="systems/py/Django/trunk/django/conf/locale/cs/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/cs/formats.py.pyindent" startline="1" endline="32">
DATE_FORMAT = 'j. F Y'
TIME_FORMAT = 'G:i:s'
DATETIME_FORMAT = 'j. F Y G:i:s'
YEAR_MONTH_FORMAT = 'F Y'
MONTH_DAY_FORMAT = 'j. F'
SHORT_DATE_FORMAT = 'd.m.Y'
SHORT_DATETIME_FORMAT = 'd.m.Y G:i:s'
FIRST_DAY_OF_WEEK = 1
DATE_INPUT_FORMATS = (
    '%d.%m.%Y', '%d.%m.%y',
    '%Y-%m-%d', '%y-%m-%d',
    '%d. %B %Y', '%d. %b. %Y',
    )
TIME_INPUT_FORMATS = (
    '%H:%M:%S',
    '%H:%M',
    )
DATETIME_INPUT_FORMATS = (
    '%d.%m.%Y %H:%M:%S',
    '%d.%m.%Y %H:%M',
    '%d.%m.%Y',
    '%Y-%m-%d %H:%M:%S',
    '%Y-%m-%d %H:%M',
    '%Y-%m-%d',
    )
DECIMAL_SEPARATOR = ','
THOUSAND_SEPARATOR = ' '
NUMBER_GROUPING = 3
</source>
<source file="systems/py/Django/trunk/django/conf/locale/te/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/te/formats.py.pyindent" startline="1" endline="18">
DATE_FORMAT = 'j F Y'
TIME_FORMAT = 'g:i:s A'

MONTH_DAY_FORMAT = 'j F'
SHORT_DATE_FORMAT = 'j M Y'

</source>
<source file="systems/py/Django/trunk/django/conf/locale/ru/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/ru/formats.py.pyindent" startline="1" endline="18">
DATE_FORMAT = 'j F Y .'
TIME_FORMAT = 'G:i:s'
YEAR_MONTH_FORMAT = 'F Y'
MONTH_DAY_FORMAT = 'j F'
SHORT_DATE_FORMAT = 'd.m.Y'

DECIMAL_SEPARATOR = ','
THOUSAND_SEPARATOR = ''
</source>
<source file="systems/py/Django/trunk/django/conf/locale/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/ro/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/ro/formats.py.pyindent" startline="1" endline="18">
DATE_FORMAT = 'j F Y'
TIME_FORMAT = 'H:i:s'
DATETIME_FORMAT = 'j F Y, H:i:s'
YEAR_MONTH_FORMAT = 'F Y'
MONTH_DAY_FORMAT = 'j F'
SHORT_DATE_FORMAT = 'd.m.Y'
SHORT_DATETIME_FORMAT = 'd.m.Y, H:i:s'

DECIMAL_SEPARATOR = ','
THOUSAND_SEPARATOR = '.'
</source>
<source file="systems/py/Django/trunk/django/conf/locale/zh_CN/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/zh_CN/formats.py.pyindent" startline="1" endline="18">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/pt/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/pt/formats.py.pyindent" startline="1" endline="18">
DATE_FORMAT = 'j \de F \de Y'
TIME_FORMAT = 'H:i:s'
YEAR_MONTH_FORMAT = 'F \de Y'
MONTH_DAY_FORMAT = 'j \de F'
SHORT_DATE_FORMAT = 'd/m/Y'

DECIMAL_SEPARATOR = ','
THOUSAND_SEPARATOR = '.'
</source>
<source file="systems/py/Django/trunk/django/conf/locale/uk/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/uk/formats.py.pyindent" startline="1" endline="18">
DATE_FORMAT = 'j F Y .'
TIME_FORMAT = 'H:i:s'
YEAR_MONTH_FORMAT = 'F Y'
MONTH_DAY_FORMAT = 'j F'
SHORT_DATE_FORMAT = 'j M Y'

DECIMAL_SEPARATOR = ','
THOUSAND_SEPARATOR = ''
</source>
<source file="systems/py/Django/trunk/django/conf/locale/sr/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/sr/formats.py.pyindent" startline="1" endline="44">
DATE_FORMAT = 'j. F Y.'
TIME_FORMAT = 'H:i'
DATETIME_FORMAT = 'j. F Y. H:i'
YEAR_MONTH_FORMAT = 'F Y.'
MONTH_DAY_FORMAT = 'j. F'
SHORT_DATE_FORMAT = 'j.m.Y.'
SHORT_DATETIME_FORMAT = 'j.m.Y. H:i'
FIRST_DAY_OF_WEEK = 1
DATE_INPUT_FORMATS = (
    '%Y-%m-%d',
    '%d.%m.%Y.', '%d.%m.%y.',
    '%d. %m. %Y.', '%d. %m. %y.',
    '%d. %b %y.', '%d. %B %y.',
    '%d. %b \'%y.', '%d. %B \'%y.',
    '%d. %b %Y.', '%d. %B %Y.',
    )
TIME_INPUT_FORMATS = (
    '%H:%M:%S',
    '%H:%M',
    )
DATETIME_INPUT_FORMATS = (
    '%Y-%m-%d %H:%M:%S',
    '%Y-%m-%d %H:%M',
    '%Y-%m-%d',
    '%d.%m.%Y. %H:%M:%S',
    '%d.%m.%Y. %H:%M',
    '%d.%m.%Y.',
    '%d.%m.%y. %H:%M:%S',
    '%d.%m.%y. %H:%M',
    '%d.%m.%y.',
    '%d. %m. %Y. %H:%M:%S',
    '%d. %m. %Y. %H:%M',
    '%d. %m. %Y.',
    '%d. %m. %y. %H:%M:%S',
    '%d. %m. %y. %H:%M',
    '%d. %m. %y.',
    )
DECIMAL_SEPARATOR = '.'
THOUSAND_SEPARATOR = ','
NUMBER_GROUPING = 3
</source>
<source file="systems/py/Django/trunk/django/conf/locale/mk/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/mk/formats.py.pyindent" startline="1" endline="18">
DATE_FORMAT = 'd F Y'
TIME_FORMAT = 'H:i:s'

SHORT_DATE_FORMAT = 'd.n.Y'

DECIMAL_SEPARATOR = ','
THOUSAND_SEPARATOR = '.'
</source>
<source file="systems/py/Django/trunk/django/conf/locale/kn/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/kn/formats.py.pyindent" startline="1" endline="18">
DATE_FORMAT = 'j F Y'
TIME_FORMAT = 'h:i:s A'

MONTH_DAY_FORMAT = 'j F'
SHORT_DATE_FORMAT = 'j M Y'

</source>
<source file="systems/py/Django/trunk/django/conf/locale/ar/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/ar/formats.py.pyindent" startline="1" endline="18">
DATE_FORMAT = 'j F Y'
TIME_FORMAT = 'g:i:s A'
YEAR_MONTH_FORMAT = 'F Y'
MONTH_DAY_FORMAT = 'j F'
SHORT_DATE_FORMAT = 'd/m/Y'

DECIMAL_SEPARATOR = ','
THOUSAND_SEPARATOR = '.'
</source>
<source file="systems/py/Django/trunk/django/conf/locale/gl/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/gl/formats.py.pyindent" startline="1" endline="18">
DATE_FORMAT = 'd F Y'
TIME_FORMAT = 'H:i:s'
YEAR_MONTH_FORMAT = 'F Y'
MONTH_DAY_FORMAT = 'j F'
SHORT_DATE_FORMAT = 'j M, Y'

DECIMAL_SEPARATOR = ','
THOUSAND_SEPARATOR = '.'
</source>
<source file="systems/py/Django/trunk/django/conf/locale/hr/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/hr/formats.py.pyindent" startline="1" endline="18">
DATE_FORMAT = 'j. F Y.'
TIME_FORMAT = 'H:i:s'
YEAR_MONTH_FORMAT = 'F Y.'
MONTH_DAY_FORMAT = 'j. F'
SHORT_DATE_FORMAT = 'j.n.Y.'

DECIMAL_SEPARATOR = ','
THOUSAND_SEPARATOR = '.'
</source>
<source file="systems/py/Django/trunk/django/conf/locale/hu/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/hu/formats.py.pyindent" startline="1" endline="18">
DATE_FORMAT = 'Y. F j.'
TIME_FORMAT = 'G:i:s'

MONTH_DAY_FORMAT = 'F j.'
SHORT_DATE_FORMAT = 'Y.m.d.'

DECIMAL_SEPARATOR = ','
THOUSAND_SEPARATOR = ''
</source>
<source file="systems/py/Django/trunk/django/conf/locale/nl/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/nl/formats.py.pyindent" startline="1" endline="48">
DATE_FORMAT = 'j F Y'
TIME_FORMAT = 'H:i'
DATETIME_FORMAT = 'j F Y H:i'
YEAR_MONTH_FORMAT = 'F Y'
MONTH_DAY_FORMAT = 'j F'
SHORT_DATE_FORMAT = 'j-n-Y'
SHORT_DATETIME_FORMAT = 'j-n-Y H:i'
FIRST_DAY_OF_WEEK = 1
DATE_INPUT_FORMATS = (
    '%d-%m-%Y', '%d-%m-%y', '%Y-%m-%d',
    '%d %b %Y', '%d %b %y',
    '%d %B %Y', '%d %B %y',
    )
TIME_INPUT_FORMATS = (
    '%H:%M:%S',
    '%H.%M:%S',
    '%H.%M',
    '%H:%M',
    )
DATETIME_INPUT_FORMATS = (
    '%d-%m-%Y %H:%M:%S', '%d-%m-%y %H:%M:%S', '%Y-%m-%d %H:%M:%S',
    '%d %b %Y %H:%M:%S', '%d %b %y %H:%M:%S',
    '%d %B %Y %H:%M:%S', '%d %B %y %H:%M:%S',
    '%d-%m-%Y %H.%M:%S', '%d-%m-%y %H.%M:%S',
    '%d %b %Y %H.%M:%S', '%d %b %y %H.%M:%S',
    '%d %B %Y %H.%M:%S', '%d %B %y %H.%M:%S',
    '%d-%m-%Y %H:%M', '%d-%m-%y %H:%M', '%Y-%m-%d %H:%M',
    '%d %b %Y %H:%M', '%d %b %y %H:%M',
    '%d %B %Y %H:%M', '%d %B %y %H:%M',
    '%d-%m-%Y %H.%M', '%d-%m-%y %H.%M',
    '%d %b %Y %H.%M', '%d %b %y %H.%M',
    '%d %B %Y %H.%M', '%d %B %y %H.%M',
    '%d-%m-%Y', '%d-%m-%y', '%Y-%m-%d',
    '%d %b %Y', '%d %b %y',
    '%d %B %Y', '%d %B %y',
    )
DECIMAL_SEPARATOR = ','
THOUSAND_SEPARATOR = '.'
NUMBER_GROUPING = 3
</source>
<source file="systems/py/Django/trunk/django/conf/locale/bg/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/bg/formats.py.pyindent" startline="1" endline="18">
DATE_FORMAT = 'd F Y'
TIME_FORMAT = 'H:i:s'

MONTH_DAY_FORMAT = 'j F'
SHORT_DATE_FORMAT = 'd.m.Y'

DECIMAL_SEPARATOR = ','
THOUSAND_SEPARATOR = ''
</source>
<source file="systems/py/Django/trunk/django/conf/locale/bn/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/bn/formats.py.pyindent" startline="1" endline="18">
DATE_FORMAT = 'j F, Y'
TIME_FORMAT = 'g:i:s A'
YEAR_MONTH_FORMAT = 'F Y'
MONTH_DAY_FORMAT = 'j F'
SHORT_DATE_FORMAT = 'j M, Y'

DECIMAL_SEPARATOR = '.'
THOUSAND_SEPARATOR = ','
</source>
<source file="systems/py/Django/trunk/django/conf/locale/es_AR/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/es_AR/formats.py.pyindent" startline="1" endline="29">
DATE_FORMAT = 'j \\de F \\de Y'
TIME_FORMAT = 'H:i:s'
DATETIME_FORMAT = 'j \\de F \\de Y \\a \\l\\a\s H:i'
YEAR_MONTH_FORMAT = 'F \\de Y'
MONTH_DAY_FORMAT = 'j \\de F'
SHORT_DATE_FORMAT = 'd/m/Y'
SHORT_DATETIME_FORMAT = 'd/m/Y H:i'
FIRST_DAY_OF_WEEK = 0
DATE_INPUT_FORMATS = (
    '%d/%m/%Y',
    '%d/%m/%y',
    )
TIME_INPUT_FORMATS = (
    '%H:%M:%S',
    '%H:%M',
    )
DATETIME_INPUT_FORMATS = (
    '%d/%m/%Y %H:%M:%S',
    '%d/%m/%Y %H:%M',
    '%d/%m/%y %H:%M:%S',
    '%d/%m/%y %H:%M',
    )
DECIMAL_SEPARATOR = ','
THOUSAND_SEPARATOR = '.'
NUMBER_GROUPING = 3
</source>
<source file="systems/py/Django/trunk/django/conf/locale/hi/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/hi/formats.py.pyindent" startline="1" endline="18">
DATE_FORMAT = 'j F Y'
TIME_FORMAT = 'g:i:s A'

MONTH_DAY_FORMAT = 'j F'
SHORT_DATE_FORMAT = 'd-m-Y'

DECIMAL_SEPARATOR = '.'
THOUSAND_SEPARATOR = ','
</source>
<source file="systems/py/Django/trunk/django/conf/locale/ka/__init__.py.pyindent" startline="1" endline="0">
</source>
<source file="systems/py/Django/trunk/django/conf/locale/ka/formats.py.pyindent" startline="1" endline="42">
DATE_FORMAT = 'l, j F, Y'
TIME_FORMAT = 'h:i:s a'
DATETIME_FORMAT = 'j F, Y h:i:s a'
YEAR_MONTH_FORMAT = 'F, Y'
MONTH_DAY_FORMAT = 'j F'
SHORT_DATE_FORMAT = 'j.M.Y'
SHORT_DATETIME_FORMAT = 'j.M.Y H:i:s'
FIRST_DAY_OF_WEEK = 1
DATE_INPUT_FORMATS = (
    '%Y-%m-%d', '%m/%d/%Y', '%m/%d/%y',
    '%d %b %Y', '%d %b, %Y', '%d %b. %Y',
    '%d %B %Y', '%d %B, %Y',
    '%d.%m.%Y', '%d.%m.%y',
    )
TIME_INPUT_FORMATS = (
    '%H:%M:%S',
    '%H:%M',
    )
DATETIME_INPUT_FORMATS = (
    '%Y-%m-%d %H:%M:%S',
    '%Y-%m-%d %H:%M',
    '%Y-%m-%d',
    '%d.%m.%Y %H:%M:%S',
    '%d.%m.%Y %H:%M',
    '%d.%m.%Y',
    '%d.%m.%y %H:%M:%S',
    '%d.%m.%y %H:%M',
    '%d.%m.%y',
    '%m/%d/%Y %H:%M:%S',
    '%m/%d/%Y %H:%M',
    '%m/%d/%Y',
    '%m/%d/%y %H:%M:%S',
    '%m/%d/%y %H:%M',
    '%m/%d/%y',
    )
DECIMAL_SEPARATOR = '.'
THOUSAND_SEPARATOR = " "
NUMBER_GROUPING = 3
</source>
